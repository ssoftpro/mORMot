diff --git a/js/public/AllocPolicy.h b/js/public/AllocPolicy.h
index 136a9c566522..3798302dc734 100644
--- a/js/public/AllocPolicy.h
+++ b/js/public/AllocPolicy.h
@@ -17,7 +17,7 @@
 #include "js/TypeDecls.h"
 #include "js/Utility.h"
 
-extern JS_PUBLIC_API void JS_ReportOutOfMemory(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_ReportOutOfMemory(JSContext* cx);
 
 namespace js {
 
diff --git a/js/public/GCAPI.h b/js/public/GCAPI.h
index b434f6be2ab4..54a24e211555 100644
--- a/js/public/GCAPI.h
+++ b/js/public/GCAPI.h
@@ -861,21 +861,21 @@ extern JS_PUBLIC_API void JS_RemoveExtraGCRootsTracer(JSContext* cx,
                                                       JSTraceDataOp traceOp,
                                                       void* data);
 
-extern JS_PUBLIC_API void JS_GC(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_GC(JSContext* cx);
 
-extern JS_PUBLIC_API void JS_MaybeGC(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_MaybeGC(JSContext* cx);
 
-extern JS_PUBLIC_API void JS_SetGCCallback(JSContext* cx, JSGCCallback cb,
+extern "C" JS_PUBLIC_API void JS_SetGCCallback(JSContext* cx, JSGCCallback cb,
                                            void* data);
 
-extern JS_PUBLIC_API void JS_SetObjectsTenuredCallback(
+extern "C" JS_PUBLIC_API void JS_SetObjectsTenuredCallback(
     JSContext* cx, JSObjectsTenuredCallback cb, void* data);
 
-extern JS_PUBLIC_API bool JS_AddFinalizeCallback(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_AddFinalizeCallback(JSContext* cx,
                                                  JSFinalizeCallback cb,
                                                  void* data);
 
-extern JS_PUBLIC_API void JS_RemoveFinalizeCallback(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_RemoveFinalizeCallback(JSContext* cx,
                                                     JSFinalizeCallback cb);
 
 /*
@@ -935,22 +935,22 @@ extern JS_PUBLIC_API void JS_UpdateWeakPointerAfterGC(
 extern JS_PUBLIC_API void JS_UpdateWeakPointerAfterGCUnbarriered(
     JSObject** objp);
 
-extern JS_PUBLIC_API void JS_SetGCParameter(JSContext* cx, JSGCParamKey key,
+extern "C" JS_PUBLIC_API void JS_SetGCParameter(JSContext* cx, JSGCParamKey key,
                                             uint32_t value);
 
 extern JS_PUBLIC_API void JS_ResetGCParameter(JSContext* cx, JSGCParamKey key);
 
-extern JS_PUBLIC_API uint32_t JS_GetGCParameter(JSContext* cx,
+extern "C" JS_PUBLIC_API uint32_t JS_GetGCParameter(JSContext* cx,
                                                 JSGCParamKey key);
 
-extern JS_PUBLIC_API void JS_SetGCParametersBasedOnAvailableMemory(
+extern "C" JS_PUBLIC_API void JS_SetGCParametersBasedOnAvailableMemory(
     JSContext* cx, uint32_t availMem);
 
 /**
  * Create a new JSString whose chars member refers to external memory, i.e.,
  * memory requiring application-specific finalization.
  */
-extern JS_PUBLIC_API JSString* JS_NewExternalString(
+extern "C" JS_PUBLIC_API JSString* JS_NewExternalString(
     JSContext* cx, const char16_t* chars, size_t length,
     const JSStringFinalizer* fin);
 
@@ -969,12 +969,12 @@ extern JS_PUBLIC_API JSString* JS_NewMaybeExternalString(
  * Return whether 'str' was created with JS_NewExternalString or
  * JS_NewExternalStringWithClosure.
  */
-extern JS_PUBLIC_API bool JS_IsExternalString(JSString* str);
+extern "C" JS_PUBLIC_API bool JS_IsExternalString(JSString* str);
 
 /**
  * Return the 'fin' arg passed to JS_NewExternalString.
  */
-extern JS_PUBLIC_API const JSStringFinalizer* JS_GetExternalStringFinalizer(
+extern "C" JS_PUBLIC_API const JSStringFinalizer* JS_GetExternalStringFinalizer(
     JSString* str);
 
 namespace JS {
diff --git a/js/public/Initialization.h b/js/public/Initialization.h
index e6907e346cb3..4920bd5bdca0 100644
--- a/js/public/Initialization.h
+++ b/js/public/Initialization.h
@@ -110,6 +110,6 @@ inline bool JS_IsInitialized(void) {
  * is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so
  * again).  This restriction may eventually be lifted.
  */
-extern JS_PUBLIC_API void JS_ShutDown(void);
+extern "C" JS_PUBLIC_API void JS_ShutDown(void);
 
 #endif /* js_Initialization_h */
diff --git a/js/src/jsapi.cpp b/js/src/jsapi.cpp
index d7b3d90adddb..1c125db9c463 100644
--- a/js/src/jsapi.cpp
+++ b/js/src/jsapi.cpp
@@ -6809,3 +6809,209 @@ JS_PUBLIC_API void NoteIntentionalCrash() {
 }
 
 }  // namespace js
+
+///////////////Orel added
+
+JS_PUBLIC_API JSObject*
+JS_NewDateObjectMsec(JSContext* cx, double msec)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+    JS::ClippedTime time = JS::TimeClip(msec);
+    return NewDateObjectMsec(cx, time);
+}
+
+JS_PUBLIC_API void*
+JS_NewRootedValue(JSContext* cx, uint64_t initial)
+{
+    return js_new<JS::RootedValue>(cx, JS::Value::fromRawBits(initial));
+}
+
+JS_PUBLIC_API void
+JS_FreeRooteValue(void* val)
+{
+    js_delete(reinterpret_cast<JS::RootedValue*>(val));
+}
+
+JS_PUBLIC_API void*
+JS_NewRootedObject(JSContext* cx, JSObject* initial)
+{
+    return js_new<JS::RootedObject>(cx, initial);
+}
+
+JS_PUBLIC_API void
+JS_FreeRootedObject(void* obj)
+{
+    js_delete(reinterpret_cast<JS::RootedObject*>(obj));
+}
+
+JS_PUBLIC_API void*
+JS_NewRootedString(JSContext* cx, JSString* initial)
+{
+    return js_new<JS::RootedString>(cx, initial);
+}
+
+JS_PUBLIC_API void
+JS_FreeRootedString(void* str)
+{
+    js_delete(reinterpret_cast<JS::RootedString*>(str));
+}
+
+
+JS_PUBLIC_API void*
+JS_NewCompileOptions(JSContext* cx)
+{
+    return js_new<JS::CompileOptions>(cx);
+}
+
+JS_PUBLIC_API void
+JS_FreeCompileOptions(void* co)
+{
+    js_delete(reinterpret_cast<JS::CompileOptions*>(co));
+}
+
+JS_PUBLIC_API void*
+JS_NewCompartmentOptions()
+{
+    return js_new<JS::CompartmentOptions>();
+}
+
+JS_PUBLIC_API void
+JS_FreeCompartmentOptions(void* opt)
+{
+    js_delete(reinterpret_cast<JS::CompartmentOptions*>(opt));
+}
+
+JS_PUBLIC_API void*
+JS_NewAutoCheckCannotGC()
+{
+    return js_new<JS::AutoCheckCannotGC>();
+}
+
+JS_PUBLIC_API void
+JS_FreeAutoCheckCannotGC(void* ac)
+{
+    js_delete(reinterpret_cast<JS::AutoCheckCannotGC*>(ac));
+}
+
+JS_PUBLIC_API void*
+JS_GetContextOptions(JSContext* cx)
+{
+    return &JS::ContextOptionsRef(cx);
+}
+
+JS_PUBLIC_API bool
+JS_EvaluateScript(JSContext* cx, const JS::CompileOptions& options,
+    const char* bytes, size_t length, JS::MutableHandleValue rval)
+{
+    return JS::Evaluate(cx, options, bytes, length, rval);
+}
+
+JS_PUBLIC_API bool
+JS_EvaluateUCScript(JSContext* cx, const JS::CompileOptions& options,
+    const char16_t* chars, size_t length, JS::MutableHandleValue rval)
+{
+    return JS::Evaluate(cx, options, chars, length, rval);
+}
+
+JS_PUBLIC_API JSObject*
+JS_NewArrayObject2(JSContext* cx, const JS::HandleValueArray& contents)
+{
+    return JS_NewArrayObject(cx, contents);
+}
+
+JS_PUBLIC_API bool
+JS_InitModuleClasses(JSContext* cx, HandleObject obj)
+{
+    //return js::InitModuleClasses(cx, obj);
+    return true;
+}
+
+JS_PUBLIC_API JSObject*
+JS_CompileModule(JSContext* cx, HandleObject obj, JS::CompileOptions& options,
+    const char16_t* chars, size_t length)
+{
+    SourceBufferHolder srcBuf(chars, length, SourceBufferHolder::NoOwnership);
+    return frontend::CompileModule(cx, options, srcBuf);
+}
+
+JS_PUBLIC_API void
+JS_SetModuleResolveHook(JSContext* cx, HandleFunction hook)
+{
+    Rooted<GlobalObject*> global(cx, cx->global());
+    global->setModuleResolveHook(hook);
+}
+
+JS_PUBLIC_API JS::Value
+JS_ComputeThis(JSContext* cx, JS::Value* vp)
+{
+    return JS::detail::ComputeThis(cx, vp);
+}
+
+JS_PUBLIC_API bool
+JS_Initialize(void)
+{
+    return JS_Init();
+}
+
+JS_PUBLIC_API uint64_t
+JS_GetReservedSlot1(JSObject* obj, uint32_t index)
+{
+    return obj->as<NativeObject>().getReservedSlot(index).asRawBits();
+}
+
+JS_PUBLIC_API JS::AutoIdVector*
+JS_EnumerateToAutoIdVector(JSContext* cx, HandleObject obj, size_t* length, jsid** data)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+    assertSameCompartment(cx, obj);
+
+    JS::AutoIdVector* v = new JS::AutoIdVector(cx);
+    if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY, v)) {
+        delete v;
+        *length = 0;
+        *data = nullptr;
+        return nullptr;
+    }
+
+    *length = v->length();
+    *data = v->begin();
+    return v;
+}
+
+JS_PUBLIC_API void
+JS_DestroyAutoIdVector(JS::AutoIdVector* v)
+{
+    delete v;
+}
+
+JS_PUBLIC_API bool
+JS_DefinePropertyByIdNative(
+    JSContext* cx, JS::HandleObject obj, JS::HandleId id,
+    JSNative getter, JSNative setter, unsigned attrs)
+{
+    JS_DefinePropertyById(cx, obj, id, getter, setter, attrs);
+}
+
+JS_PUBLIC_API bool
+JS_DefinePropertyNative(
+    JSContext* cx, JS::HandleObject obj, const char* name,
+    JSNative getter, JSNative setter, unsigned attrs)
+{
+    JS_DefinePropertyNative(cx, obj, name, getter, setter, attrs);
+}
+
+JS_PUBLIC_API bool
+JS_DefineUCPropertyNative(
+    JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
+    JSNative getter, JSNative setter, unsigned attrs)
+{
+    JS_DefineUCProperty(cx, obj, name, namelen, getter, setter, attrs);
+}
+
+JS_PUBLIC_API bool
+JS_IsRunning(JSContext* cx)
+{
+    return !!cx->activation();
+}
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
index 0f11787f6cd5..d11850aa3bcf 100644
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -679,34 +679,34 @@ static const unsigned JSPROP_IGNORE_PERMANENT = 0x10000;
 static const unsigned JSPROP_IGNORE_VALUE = 0x20000;
 
 /** Microseconds since the epoch, midnight, January 1, 1970 UTC. */
-extern JS_PUBLIC_API int64_t JS_Now(void);
+extern "C" JS_PUBLIC_API int64_t JS_Now(void);
 
 /** Don't want to export data, so provide accessors for non-inline Values. */
-extern JS_PUBLIC_API JS::Value JS_GetNaNValue(JSContext* cx);
+extern "C" JS_PUBLIC_API JS::Value JS_GetNaNValue(JSContext* cx);
 
-extern JS_PUBLIC_API JS::Value JS_GetNegativeInfinityValue(JSContext* cx);
+extern "C" JS_PUBLIC_API JS::Value JS_GetNegativeInfinityValue(JSContext* cx);
 
-extern JS_PUBLIC_API JS::Value JS_GetPositiveInfinityValue(JSContext* cx);
+extern "C" JS_PUBLIC_API JS::Value JS_GetPositiveInfinityValue(JSContext* cx);
 
-extern JS_PUBLIC_API JS::Value JS_GetEmptyStringValue(JSContext* cx);
+extern "C" JS_PUBLIC_API JS::Value JS_GetEmptyStringValue(JSContext* cx);
 
-extern JS_PUBLIC_API JSString* JS_GetEmptyString(JSContext* cx);
+extern "C" JS_PUBLIC_API JSString* JS_GetEmptyString(JSContext* cx);
 
-extern JS_PUBLIC_API bool JS_ValueToObject(JSContext* cx, JS::HandleValue v,
+extern "C" JS_PUBLIC_API bool JS_ValueToObject(JSContext* cx, JS::HandleValue v,
                                            JS::MutableHandleObject objp);
 
-extern JS_PUBLIC_API JSFunction* JS_ValueToFunction(JSContext* cx,
+extern "C" JS_PUBLIC_API JSFunction* JS_ValueToFunction(JSContext* cx,
                                                     JS::HandleValue v);
 
-extern JS_PUBLIC_API JSFunction* JS_ValueToConstructor(JSContext* cx,
+extern "C" JS_PUBLIC_API JSFunction* JS_ValueToConstructor(JSContext* cx,
                                                        JS::HandleValue v);
 
-extern JS_PUBLIC_API JSString* JS_ValueToSource(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_ValueToSource(JSContext* cx,
                                                 JS::Handle<JS::Value> v);
 
 extern JS_PUBLIC_API bool JS_DoubleIsInt32(double d, int32_t* ip);
 
-extern JS_PUBLIC_API JSType JS_TypeOfValue(JSContext* cx,
+extern "C" JS_PUBLIC_API JSType JS_TypeOfValue(JSContext* cx,
                                            JS::Handle<JS::Value> v);
 
 namespace JS {
@@ -715,24 +715,24 @@ extern JS_PUBLIC_API const char* InformalValueTypeName(const JS::Value& v);
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API bool JS_StrictlyEqual(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_StrictlyEqual(JSContext* cx,
                                            JS::Handle<JS::Value> v1,
                                            JS::Handle<JS::Value> v2,
                                            bool* equal);
 
-extern JS_PUBLIC_API bool JS_LooselyEqual(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_LooselyEqual(JSContext* cx,
                                           JS::Handle<JS::Value> v1,
                                           JS::Handle<JS::Value> v2,
                                           bool* equal);
 
-extern JS_PUBLIC_API bool JS_SameValue(JSContext* cx, JS::Handle<JS::Value> v1,
+extern "C" JS_PUBLIC_API bool JS_SameValue(JSContext* cx, JS::Handle<JS::Value> v1,
                                        JS::Handle<JS::Value> v2, bool* same);
 
 /** True iff fun is the global eval function. */
-extern JS_PUBLIC_API bool JS_IsBuiltinEvalFunction(JSFunction* fun);
+extern "C" JS_PUBLIC_API bool JS_IsBuiltinEvalFunction(JSFunction* fun);
 
 /** True iff fun is the Function constructor. */
-extern JS_PUBLIC_API bool JS_IsBuiltinFunctionConstructor(JSFunction* fun);
+extern "C" JS_PUBLIC_API bool JS_IsBuiltinFunctionConstructor(JSFunction* fun);
 
 /************************************************************************/
 
@@ -748,7 +748,7 @@ extern JS_PUBLIC_API bool JS_IsBuiltinFunctionConstructor(JSFunction* fun);
 
 // Create a new runtime, with a single cooperative context for this thread.
 // On success, the new context will be the active context for the runtime.
-extern JS_PUBLIC_API JSContext* JS_NewContext(
+extern "C" JS_PUBLIC_API JSContext* JS_NewContext(
     uint32_t maxbytes, uint32_t maxNurseryBytes = JS::DefaultNurseryBytes,
     JSRuntime* parentRuntime = nullptr);
 
@@ -790,21 +790,21 @@ struct AutoRelinquishZoneGroups {
 // Destroy a context allocated with JS_NewContext or JS_NewCooperativeContext.
 // The context must be the current active context in the runtime, and after
 // this call the runtime will have no active context.
-extern JS_PUBLIC_API void JS_DestroyContext(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_DestroyContext(JSContext* cx);
 
-JS_PUBLIC_API void* JS_GetContextPrivate(JSContext* cx);
+extern "C" JS_PUBLIC_API void* JS_GetContextPrivate(JSContext* cx);
 
-JS_PUBLIC_API void JS_SetContextPrivate(JSContext* cx, void* data);
+extern "C" JS_PUBLIC_API void JS_SetContextPrivate(JSContext* cx, void* data);
 
-extern JS_PUBLIC_API JSRuntime* JS_GetParentRuntime(JSContext* cx);
+extern "C" JS_PUBLIC_API JSRuntime* JS_GetParentRuntime(JSContext* cx);
 
-extern JS_PUBLIC_API JSRuntime* JS_GetRuntime(JSContext* cx);
+extern "C" JS_PUBLIC_API JSRuntime* JS_GetRuntime(JSContext* cx);
 
-extern JS_PUBLIC_API void JS_BeginRequest(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_BeginRequest(JSContext* cx);
 
-extern JS_PUBLIC_API void JS_EndRequest(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_EndRequest(JSContext* cx);
 
-extern JS_PUBLIC_API void JS_SetFutexCanWait(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_SetFutexCanWait(JSContext* cx);
 
 namespace JS {
 
@@ -1095,7 +1095,7 @@ JS_PUBLIC_API ContextOptions& ContextOptionsRef(JSContext* cx);
  * exactly once per runtime/context, before the first JS_NewGlobalObject
  * call.
  */
-JS_PUBLIC_API bool InitSelfHostedCode(JSContext* cx);
+extern "C" JS_PUBLIC_API bool InitSelfHostedCode(JSContext* cx);
 
 /**
  * Asserts (in debug and release builds) that `obj` belongs to the current
@@ -1105,18 +1105,18 @@ JS_PUBLIC_API void AssertObjectBelongsToCurrentThread(JSObject* obj);
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API const char* JS_GetImplementationVersion(void);
+extern "C" JS_PUBLIC_API const char* JS_GetImplementationVersion(void);
 
-extern JS_PUBLIC_API void JS_SetDestroyCompartmentCallback(
+extern "C" JS_PUBLIC_API void JS_SetDestroyCompartmentCallback(
     JSContext* cx, JSDestroyCompartmentCallback callback);
 
-extern JS_PUBLIC_API void JS_SetSizeOfIncludingThisCompartmentCallback(
+extern "C" JS_PUBLIC_API void JS_SetSizeOfIncludingThisCompartmentCallback(
     JSContext* cx, JSSizeOfIncludingThisCompartmentCallback callback);
 
-extern JS_PUBLIC_API void JS_SetCompartmentNameCallback(
+extern "C" JS_PUBLIC_API void JS_SetCompartmentNameCallback(
     JSContext* cx, JSCompartmentNameCallback callback);
 
-extern JS_PUBLIC_API void JS_SetWrapObjectCallbacks(
+extern "C" JS_PUBLIC_API void JS_SetWrapObjectCallbacks(
     JSContext* cx, const JSWrapObjectCallbacks* callbacks);
 
 extern JS_PUBLIC_API void JS_SetExternalStringSizeofCallback(
@@ -1149,26 +1149,26 @@ extern JS_PUBLIC_API mozilla::Maybe<JSExnType> JS_GetErrorType(
 
 #endif  // defined(NIGHTLY_BUILD)
 
-extern JS_PUBLIC_API void JS_SetCompartmentPrivate(JSCompartment* compartment,
+extern "C" JS_PUBLIC_API void JS_SetCompartmentPrivate(JSCompartment* compartment,
                                                    void* data);
 
-extern JS_PUBLIC_API void* JS_GetCompartmentPrivate(JSCompartment* compartment);
+extern "C" JS_PUBLIC_API void* JS_GetCompartmentPrivate(JSCompartment* compartment);
 
-extern JS_PUBLIC_API void JS_SetZoneUserData(JS::Zone* zone, void* data);
+extern "C" JS_PUBLIC_API void JS_SetZoneUserData(JS::Zone* zone, void* data);
 
-extern JS_PUBLIC_API void* JS_GetZoneUserData(JS::Zone* zone);
+extern "C" JS_PUBLIC_API void* JS_GetZoneUserData(JS::Zone* zone);
 
-extern JS_PUBLIC_API bool JS_WrapObject(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_WrapObject(JSContext* cx,
                                         JS::MutableHandleObject objp);
 
-extern JS_PUBLIC_API bool JS_WrapValue(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_WrapValue(JSContext* cx,
                                        JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API JSObject* JS_TransplantObject(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_TransplantObject(JSContext* cx,
                                                    JS::HandleObject origobj,
                                                    JS::HandleObject target);
 
-extern JS_PUBLIC_API bool JS_RefreshCrossCompartmentWrappers(
+extern "C" JS_PUBLIC_API bool JS_RefreshCrossCompartmentWrappers(
     JSContext* cx, JS::Handle<JSObject*> obj);
 
 /*
@@ -1240,10 +1240,10 @@ class MOZ_RAII JS_PUBLIC_API JSAutoNullableCompartment {
  * Entering a compartment roots the compartment and its global object until the
  * matching JS_LeaveCompartment() call.
  */
-extern JS_PUBLIC_API JSCompartment* JS_EnterCompartment(JSContext* cx,
+extern "C" JS_PUBLIC_API JSCompartment* JS_EnterCompartment(JSContext* cx,
                                                         JSObject* target);
 
-extern JS_PUBLIC_API void JS_LeaveCompartment(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_LeaveCompartment(JSContext* cx,
                                               JSCompartment* oldCompartment);
 
 typedef void (*JSIterateCompartmentCallback)(JSContext* cx, void* data,
@@ -1254,7 +1254,7 @@ typedef void (*JSIterateCompartmentCallback)(JSContext* cx, void* data,
  * there is no guarantee that the compartment will survive after the callback
  * returns. Also, barriers are disabled via the TraceSession.
  */
-extern JS_PUBLIC_API void JS_IterateCompartments(
+extern "C" JS_PUBLIC_API void JS_IterateCompartments(
     JSContext* cx, void* data,
     JSIterateCompartmentCallback compartmentCallback);
 
@@ -1280,7 +1280,7 @@ extern JS_PUBLIC_API void JS_MarkCrossZoneIdValue(JSContext* cx,
  *
  * NB: This sets cx's global object to obj if it was null.
  */
-extern JS_PUBLIC_API bool JS_InitStandardClasses(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_InitStandardClasses(JSContext* cx,
                                                  JS::Handle<JSObject*> obj);
 
 /**
@@ -1297,26 +1297,26 @@ extern JS_PUBLIC_API bool JS_InitStandardClasses(JSContext* cx,
  * calls JS_NewEnumerateStandardClasses. newEnumerate is preferred because it's
  * faster (does not define all standard classes).
  */
-extern JS_PUBLIC_API bool JS_ResolveStandardClass(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_ResolveStandardClass(JSContext* cx,
                                                   JS::HandleObject obj,
                                                   JS::HandleId id,
                                                   bool* resolved);
 
-extern JS_PUBLIC_API bool JS_MayResolveStandardClass(const JSAtomState& names,
+extern "C" JS_PUBLIC_API bool JS_MayResolveStandardClass(const JSAtomState& names,
                                                      jsid id,
                                                      JSObject* maybeObj);
 
-extern JS_PUBLIC_API bool JS_EnumerateStandardClasses(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_EnumerateStandardClasses(JSContext* cx,
                                                       JS::HandleObject obj);
 
 extern JS_PUBLIC_API bool JS_NewEnumerateStandardClasses(
     JSContext* cx, JS::HandleObject obj, JS::AutoIdVector& properties,
     bool enumerableOnly);
 
-extern JS_PUBLIC_API bool JS_GetClassObject(JSContext* cx, JSProtoKey key,
+extern "C" JS_PUBLIC_API bool JS_GetClassObject(JSContext* cx, JSProtoKey key,
                                             JS::MutableHandle<JSObject*> objp);
 
-extern JS_PUBLIC_API bool JS_GetClassPrototype(
+extern "C" JS_PUBLIC_API bool JS_GetClassPrototype(
     JSContext* cx, JSProtoKey key, JS::MutableHandle<JSObject*> objp);
 
 namespace JS {
@@ -1341,62 +1341,62 @@ extern JS_PUBLIC_API void ProtoKeyToId(JSContext* cx, JSProtoKey key,
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API JSProtoKey JS_IdToProtoKey(JSContext* cx, JS::HandleId id);
+extern "C" JS_PUBLIC_API JSProtoKey JS_IdToProtoKey(JSContext* cx, JS::HandleId id);
 
 /**
  * Returns the original value of |Function.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API JSObject* JS_GetFunctionPrototype(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_GetFunctionPrototype(JSContext* cx,
                                                        JS::HandleObject forObj);
 
 /**
  * Returns the original value of |Object.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API JSObject* JS_GetObjectPrototype(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_GetObjectPrototype(JSContext* cx,
                                                      JS::HandleObject forObj);
 
 /**
  * Returns the original value of |Array.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API JSObject* JS_GetArrayPrototype(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_GetArrayPrototype(JSContext* cx,
                                                     JS::HandleObject forObj);
 
 /**
  * Returns the original value of |Error.prototype| from the global
  * object of the current compartment of cx.
  */
-extern JS_PUBLIC_API JSObject* JS_GetErrorPrototype(JSContext* cx);
+extern "C" JS_PUBLIC_API JSObject* JS_GetErrorPrototype(JSContext* cx);
 
 /**
  * Returns the %IteratorPrototype% object that all built-in iterator prototype
  * chains go through for the global object of the current compartment of cx.
  */
-extern JS_PUBLIC_API JSObject* JS_GetIteratorPrototype(JSContext* cx);
+extern "C" JS_PUBLIC_API JSObject* JS_GetIteratorPrototype(JSContext* cx);
 
-extern JS_PUBLIC_API JSObject* JS_GetGlobalForObject(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_GetGlobalForObject(JSContext* cx,
                                                      JSObject* obj);
 
-extern JS_PUBLIC_API bool JS_IsGlobalObject(JSObject* obj);
+extern "C" JS_PUBLIC_API bool JS_IsGlobalObject(JSObject* obj);
 
-extern JS_PUBLIC_API JSObject* JS_GlobalLexicalEnvironment(JSObject* obj);
+extern "C" JS_PUBLIC_API JSObject* JS_GlobalLexicalEnvironment(JSObject* obj);
 
-extern JS_PUBLIC_API bool JS_HasExtensibleLexicalEnvironment(JSObject* obj);
+extern "C" JS_PUBLIC_API bool JS_HasExtensibleLexicalEnvironment(JSObject* obj);
 
-extern JS_PUBLIC_API JSObject* JS_ExtensibleLexicalEnvironment(JSObject* obj);
+extern "C" JS_PUBLIC_API JSObject* JS_ExtensibleLexicalEnvironment(JSObject* obj);
 
 /**
  * May return nullptr, if |c| never had a global (e.g. the atoms compartment),
  * or if |c|'s global has been collected.
  */
-extern JS_PUBLIC_API JSObject* JS_GetGlobalForCompartmentOrNull(
+extern "C" JS_PUBLIC_API JSObject* JS_GetGlobalForCompartmentOrNull(
     JSContext* cx, JSCompartment* c);
 
 namespace JS {
 
-extern JS_PUBLIC_API JSObject* CurrentGlobalOrNull(JSContext* cx);
+extern "C" JS_PUBLIC_API JSObject* CurrentGlobalOrNull(JSContext* cx);
 
 }  // namespace JS
 
@@ -1404,18 +1404,18 @@ extern JS_PUBLIC_API JSObject* CurrentGlobalOrNull(JSContext* cx);
  * Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the
  * given global.
  */
-extern JS_PUBLIC_API bool JS_InitReflectParse(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_InitReflectParse(JSContext* cx,
                                               JS::HandleObject global);
 
 /**
  * Add various profiling-related functions as properties of the given object.
  * Defined in builtin/Profilers.cpp.
  */
-extern JS_PUBLIC_API bool JS_DefineProfilingFunctions(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DefineProfilingFunctions(JSContext* cx,
                                                       JS::HandleObject obj);
 
 /* Defined in vm/Debugger.cpp. */
-extern JS_PUBLIC_API bool JS_DefineDebuggerObject(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DefineDebuggerObject(JSContext* cx,
                                                   JS::HandleObject obj);
 
 #ifdef JS_HAS_CTYPES
@@ -1423,7 +1423,7 @@ extern JS_PUBLIC_API bool JS_DefineDebuggerObject(JSContext* cx,
  * Initialize the 'ctypes' object on a global variable 'obj'. The 'ctypes'
  * object will be sealed.
  */
-extern JS_PUBLIC_API bool JS_InitCTypesClass(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_InitCTypesClass(JSContext* cx,
                                              JS::HandleObject global);
 
 /**
@@ -1450,13 +1450,13 @@ struct JSCTypesCallbacks {
  * may safely be altered after calling this function and without having
  * to call this function again.
  */
-extern JS_PUBLIC_API void JS_SetCTypesCallbacks(
+extern "C" JS_PUBLIC_API void JS_SetCTypesCallbacks(
     JSObject* ctypesObj, const JSCTypesCallbacks* callbacks);
 #endif
 
-extern JS_PUBLIC_API void* JS_malloc(JSContext* cx, size_t nbytes);
+extern "C" JS_PUBLIC_API void* JS_malloc(JSContext* cx, size_t nbytes);
 
-extern JS_PUBLIC_API void* JS_realloc(JSContext* cx, void* p, size_t oldBytes,
+extern "C" JS_PUBLIC_API void* JS_realloc(JSContext* cx, void* p, size_t oldBytes,
                                       size_t newBytes);
 
 /**
@@ -1464,17 +1464,17 @@ extern JS_PUBLIC_API void* JS_realloc(JSContext* cx, void* p, size_t oldBytes,
  * performance optimization.
  * cx may be nullptr.
  */
-extern JS_PUBLIC_API void JS_free(JSContext* cx, void* p);
+extern "C" JS_PUBLIC_API void JS_free(JSContext* cx, void* p);
 
 /**
  * A wrapper for js_free(p) that may delay js_free(p) invocation as a
  * performance optimization as specified by the given JSFreeOp instance.
  */
-extern JS_PUBLIC_API void JS_freeop(JSFreeOp* fop, void* p);
+extern "C" JS_PUBLIC_API void JS_freeop(JSFreeOp* fop, void* p);
 
-extern JS_PUBLIC_API void JS_updateMallocCounter(JSContext* cx, size_t nbytes);
+extern "C" JS_PUBLIC_API void JS_updateMallocCounter(JSContext* cx, size_t nbytes);
 
-extern JS_PUBLIC_API char* JS_strdup(JSContext* cx, const char* s);
+extern "C" JS_PUBLIC_API char* JS_strdup(JSContext* cx, const char* s);
 
 /**
  * Set the size of the native stack that should not be exceed. To disable
@@ -1494,19 +1494,19 @@ extern JS_PUBLIC_API char* JS_strdup(JSContext* cx, const char* s);
  * This function may only be called immediately after the runtime is initialized
  * and before any code is executed and/or interrupts requested.
  */
-extern JS_PUBLIC_API void JS_SetNativeStackQuota(
+extern "C" JS_PUBLIC_API void JS_SetNativeStackQuota(
     JSContext* cx, size_t systemCodeStackSize,
     size_t trustedScriptStackSize = 0, size_t untrustedScriptStackSize = 0);
 
 /************************************************************************/
 
-extern JS_PUBLIC_API bool JS_ValueToId(JSContext* cx, JS::HandleValue v,
+extern "C" JS_PUBLIC_API bool JS_ValueToId(JSContext* cx, JS::HandleValue v,
                                        JS::MutableHandleId idp);
 
-extern JS_PUBLIC_API bool JS_StringToId(JSContext* cx, JS::HandleString s,
+extern "C" JS_PUBLIC_API bool JS_StringToId(JSContext* cx, JS::HandleString s,
                                         JS::MutableHandleId idp);
 
-extern JS_PUBLIC_API bool JS_IdToValue(JSContext* cx, jsid id,
+extern "C" JS_PUBLIC_API bool JS_IdToValue(JSContext* cx, jsid id,
                                        JS::MutableHandle<JS::Value> vp);
 
 namespace JS {
@@ -1809,7 +1809,7 @@ struct JSFunctionSpec {
 #define JS_FNSPEC(name, call, info, nargs, flags, selfHostedName) \
   { name, {call, info}, nargs, flags, selfHostedName }
 
-extern JS_PUBLIC_API JSObject* JS_InitClass(
+extern "C" JS_PUBLIC_API JSObject* JS_InitClass(
     JSContext* cx, JS::HandleObject obj, JS::HandleObject parent_proto,
     const JSClass* clasp, JSNative constructor, unsigned nargs,
     const JSPropertySpec* ps, const JSFunctionSpec* fs,
@@ -1819,17 +1819,17 @@ extern JS_PUBLIC_API JSObject* JS_InitClass(
  * Set up ctor.prototype = proto and proto.constructor = ctor with the
  * right property flags.
  */
-extern JS_PUBLIC_API bool JS_LinkConstructorAndPrototype(
+extern "C" JS_PUBLIC_API bool JS_LinkConstructorAndPrototype(
     JSContext* cx, JS::Handle<JSObject*> ctor, JS::Handle<JSObject*> proto);
 
-extern JS_PUBLIC_API const JSClass* JS_GetClass(JSObject* obj);
+extern "C" JS_PUBLIC_API const JSClass* JS_GetClass(JSObject* obj);
 
-extern JS_PUBLIC_API bool JS_InstanceOf(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_InstanceOf(JSContext* cx,
                                         JS::Handle<JSObject*> obj,
                                         const JSClass* clasp,
                                         JS::CallArgs* args);
 
-extern JS_PUBLIC_API bool JS_HasInstance(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_HasInstance(JSContext* cx,
                                          JS::Handle<JSObject*> obj,
                                          JS::Handle<JS::Value> v, bool* bp);
 
@@ -1845,16 +1845,16 @@ extern JS_PUBLIC_API bool OrdinaryHasInstance(JSContext* cx,
 
 }  // namespace JS
 
-extern JS_PUBLIC_API void* JS_GetPrivate(JSObject* obj);
+extern "C" JS_PUBLIC_API void* JS_GetPrivate(JSObject* obj);
 
-extern JS_PUBLIC_API void JS_SetPrivate(JSObject* obj, void* data);
+extern "C" JS_PUBLIC_API void JS_SetPrivate(JSObject* obj, void* data);
 
-extern JS_PUBLIC_API void* JS_GetInstancePrivate(JSContext* cx,
+extern "C" JS_PUBLIC_API void* JS_GetInstancePrivate(JSContext* cx,
                                                  JS::Handle<JSObject*> obj,
                                                  const JSClass* clasp,
                                                  JS::CallArgs* args);
 
-extern JS_PUBLIC_API JSObject* JS_GetConstructor(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_GetConstructor(JSContext* cx,
                                                  JS::Handle<JSObject*> proto);
 
 namespace JS {
@@ -2133,7 +2133,7 @@ enum OnNewGlobalHookOption { FireOnNewGlobalHook, DontFireOnNewGlobalHook };
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API JSObject* JS_NewGlobalObject(
+extern "C" JS_PUBLIC_API JSObject* JS_NewGlobalObject(
     JSContext* cx, const JSClass* clasp, JSPrincipals* principals,
     JS::OnNewGlobalHookOption hookOption,
     const JS::CompartmentOptions& options);
@@ -2147,40 +2147,40 @@ extern JS_PUBLIC_API JSObject* JS_NewGlobalObject(
  * It is still possible to specify custom trace hooks for global object classes.
  * They can be provided via the CompartmentOptions passed to JS_NewGlobalObject.
  */
-extern JS_PUBLIC_API void JS_GlobalObjectTraceHook(JSTracer* trc,
+extern "C" JS_PUBLIC_API void JS_GlobalObjectTraceHook(JSTracer* trc,
                                                    JSObject* global);
 
-extern JS_PUBLIC_API void JS_FireOnNewGlobalObject(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_FireOnNewGlobalObject(JSContext* cx,
                                                    JS::HandleObject global);
 
-extern JS_PUBLIC_API JSObject* JS_NewObject(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_NewObject(JSContext* cx,
                                             const JSClass* clasp);
 
-extern JS_PUBLIC_API bool JS_IsNative(JSObject* obj);
+extern "C" JS_PUBLIC_API bool JS_IsNative(JSObject* obj);
 
 /**
  * Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
  * proto. If proto is nullptr, the JS object will have `null` as [[Prototype]].
  */
-extern JS_PUBLIC_API JSObject* JS_NewObjectWithGivenProto(
+extern "C" JS_PUBLIC_API JSObject* JS_NewObjectWithGivenProto(
     JSContext* cx, const JSClass* clasp, JS::Handle<JSObject*> proto);
 
 /** Creates a new plain object, like `new Object()`, with Object.prototype as
  * [[Prototype]]. */
-extern JS_PUBLIC_API JSObject* JS_NewPlainObject(JSContext* cx);
+extern "C" JS_PUBLIC_API JSObject* JS_NewPlainObject(JSContext* cx);
 
 /**
  * Freeze obj, and all objects it refers to, recursively. This will not recurse
  * through non-extensible objects, on the assumption that those are already
  * deep-frozen.
  */
-extern JS_PUBLIC_API bool JS_DeepFreezeObject(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DeepFreezeObject(JSContext* cx,
                                               JS::Handle<JSObject*> obj);
 
 /**
  * Freezes an object; see ES5's Object.freeze(obj) method.
  */
-extern JS_PUBLIC_API bool JS_FreezeObject(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_FreezeObject(JSContext* cx,
                                           JS::Handle<JSObject*> obj);
 
 /*** Property descriptors ***************************************************/
@@ -2488,7 +2488,7 @@ extern JS_PUBLIC_API bool FromPropertyDescriptor(
  *
  * Implements: ES6 [[GetPrototypeOf]] internal method.
  */
-extern JS_PUBLIC_API bool JS_GetPrototype(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_GetPrototype(JSContext* cx, JS::HandleObject obj,
                                           JS::MutableHandleObject result);
 
 /**
@@ -2498,7 +2498,7 @@ extern JS_PUBLIC_API bool JS_GetPrototype(JSContext* cx, JS::HandleObject obj,
  * in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both
  * outparams have unspecified value.
  */
-extern JS_PUBLIC_API bool JS_GetPrototypeIfOrdinary(
+extern "C" JS_PUBLIC_API bool JS_GetPrototypeIfOrdinary(
     JSContext* cx, JS::HandleObject obj, bool* isOrdinary,
     JS::MutableHandleObject result);
 
@@ -2515,7 +2515,7 @@ extern JS_PUBLIC_API bool JS_GetPrototypeIfOrdinary(
  * all other objects in the same "group" as obj to be permanently deoptimized.
  * It's better to create the object with the right prototype from the start.
  */
-extern JS_PUBLIC_API bool JS_SetPrototype(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_SetPrototype(JSContext* cx, JS::HandleObject obj,
                                           JS::HandleObject proto);
 
 /**
@@ -2525,7 +2525,7 @@ extern JS_PUBLIC_API bool JS_SetPrototype(JSContext* cx, JS::HandleObject obj,
  *
  * Implements: ES6 [[IsExtensible]] internal method.
  */
-extern JS_PUBLIC_API bool JS_IsExtensible(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_IsExtensible(JSContext* cx, JS::HandleObject obj,
                                           bool* extensible);
 
 /**
@@ -2536,7 +2536,7 @@ extern JS_PUBLIC_API bool JS_IsExtensible(JSContext* cx, JS::HandleObject obj,
  *
  * Implements: ES6 [[PreventExtensions]] internal method.
  */
-extern JS_PUBLIC_API bool JS_PreventExtensions(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_PreventExtensions(JSContext* cx,
                                                JS::HandleObject obj,
                                                JS::ObjectOpResult& result);
 
@@ -2549,7 +2549,7 @@ extern JS_PUBLIC_API bool JS_PreventExtensions(JSContext* cx,
  *
  * This is a nonstandard internal method.
  */
-extern JS_PUBLIC_API bool JS_SetImmutablePrototype(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_SetImmutablePrototype(JSContext* cx,
                                                    JS::HandleObject obj,
                                                    bool* succeeded);
 
@@ -2559,15 +2559,15 @@ extern JS_PUBLIC_API bool JS_SetImmutablePrototype(JSContext* cx,
  *
  * Implements: ES6 [[GetOwnProperty]] internal method.
  */
-extern JS_PUBLIC_API bool JS_GetOwnPropertyDescriptorById(
+extern "C" JS_PUBLIC_API bool JS_GetOwnPropertyDescriptorById(
     JSContext* cx, JS::HandleObject obj, JS::HandleId id,
     JS::MutableHandle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API bool JS_GetOwnPropertyDescriptor(
+extern "C" JS_PUBLIC_API bool JS_GetOwnPropertyDescriptor(
     JSContext* cx, JS::HandleObject obj, const char* name,
     JS::MutableHandle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API bool JS_GetOwnUCPropertyDescriptor(
+extern "C" JS_PUBLIC_API bool JS_GetOwnUCPropertyDescriptor(
     JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
     JS::MutableHandle<JS::PropertyDescriptor> desc);
 
@@ -2577,15 +2577,15 @@ extern JS_PUBLIC_API bool JS_GetOwnUCPropertyDescriptor(
  * property is found is returned in desc.object(). If the property is not found
  * on the prototype chain, this returns true with desc.object() set to null.
  */
-extern JS_PUBLIC_API bool JS_GetPropertyDescriptorById(
+extern "C" JS_PUBLIC_API bool JS_GetPropertyDescriptorById(
     JSContext* cx, JS::HandleObject obj, JS::HandleId id,
     JS::MutableHandle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API bool JS_GetPropertyDescriptor(
+extern "C" JS_PUBLIC_API bool JS_GetPropertyDescriptor(
     JSContext* cx, JS::HandleObject obj, const char* name,
     JS::MutableHandle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API bool JS_GetUCPropertyDescriptor(
+extern "C" JS_PUBLIC_API bool JS_GetUCPropertyDescriptor(
     JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
     JS::MutableHandle<JS::PropertyDescriptor> desc);
 
@@ -2612,7 +2612,7 @@ extern JS_PUBLIC_API bool JS_DefinePropertyById(
     JSContext* cx, JS::HandleObject obj, JS::HandleId id,
     JS::Handle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API bool JS_DefinePropertyById(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DefinePropertyById(JSContext* cx,
                                                 JS::HandleObject obj,
                                                 JS::HandleId id,
                                                 JS::HandleValue value,
@@ -2649,7 +2649,7 @@ extern JS_PUBLIC_API bool JS_DefinePropertyById(JSContext* cx,
                                                 JS::HandleId id, double value,
                                                 unsigned attrs);
 
-extern JS_PUBLIC_API bool JS_DefineProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_DefineProperty(JSContext* cx, JS::HandleObject obj,
                                             const char* name,
                                             JS::HandleValue value,
                                             unsigned attrs);
@@ -2688,7 +2688,7 @@ extern JS_PUBLIC_API bool JS_DefineUCProperty(
     JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
     JS::Handle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API bool JS_DefineUCProperty(
+extern "C" JS_PUBLIC_API bool JS_DefineUCProperty(
     JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
     JS::HandleValue value, unsigned attrs);
 
@@ -2729,7 +2729,7 @@ extern JS_PUBLIC_API bool JS_DefineElement(JSContext* cx, JS::HandleObject obj,
                                            JS::HandleValue value,
                                            unsigned attrs);
 
-extern JS_PUBLIC_API bool JS_DefineElement(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_DefineElement(JSContext* cx, JS::HandleObject obj,
                                            uint32_t index, JSNative getter,
                                            JSNative setter, unsigned attrs);
 
@@ -2764,18 +2764,18 @@ extern JS_PUBLIC_API bool JS_DefineElement(JSContext* cx, JS::HandleObject obj,
  *
  * Implements: ES6 [[Has]] internal method.
  */
-extern JS_PUBLIC_API bool JS_HasPropertyById(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_HasPropertyById(JSContext* cx,
                                              JS::HandleObject obj,
                                              JS::HandleId id, bool* foundp);
 
-extern JS_PUBLIC_API bool JS_HasProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_HasProperty(JSContext* cx, JS::HandleObject obj,
                                          const char* name, bool* foundp);
 
-extern JS_PUBLIC_API bool JS_HasUCProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_HasUCProperty(JSContext* cx, JS::HandleObject obj,
                                            const char16_t* name, size_t namelen,
                                            bool* vp);
 
-extern JS_PUBLIC_API bool JS_HasElement(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_HasElement(JSContext* cx, JS::HandleObject obj,
                                         uint32_t index, bool* foundp);
 
 /**
@@ -2783,11 +2783,11 @@ extern JS_PUBLIC_API bool JS_HasElement(JSContext* cx, JS::HandleObject obj,
  *
  * Implements: ES6 7.3.11 HasOwnProperty(O, P).
  */
-extern JS_PUBLIC_API bool JS_HasOwnPropertyById(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_HasOwnPropertyById(JSContext* cx,
                                                 JS::HandleObject obj,
                                                 JS::HandleId id, bool* foundp);
 
-extern JS_PUBLIC_API bool JS_HasOwnProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_HasOwnProperty(JSContext* cx, JS::HandleObject obj,
                                             const char* name, bool* foundp);
 
 /**
@@ -2801,13 +2801,13 @@ extern JS_PUBLIC_API bool JS_HasOwnProperty(JSContext* cx, JS::HandleObject obj,
  *
  * Implements: ES6 [[Get]] internal method.
  */
-extern JS_PUBLIC_API bool JS_ForwardGetPropertyTo(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_ForwardGetPropertyTo(JSContext* cx,
                                                   JS::HandleObject obj,
                                                   JS::HandleId id,
                                                   JS::HandleValue receiver,
                                                   JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API bool JS_ForwardGetElementTo(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_ForwardGetElementTo(JSContext* cx,
                                                  JS::HandleObject obj,
                                                  uint32_t index,
                                                  JS::HandleObject receiver,
@@ -2819,20 +2819,20 @@ extern JS_PUBLIC_API bool JS_ForwardGetElementTo(JSContext* cx,
  *
  * Implements: ES6 7.3.1 Get(O, P).
  */
-extern JS_PUBLIC_API bool JS_GetPropertyById(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_GetPropertyById(JSContext* cx,
                                              JS::HandleObject obj,
                                              JS::HandleId id,
                                              JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API bool JS_GetProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_GetProperty(JSContext* cx, JS::HandleObject obj,
                                          const char* name,
                                          JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API bool JS_GetUCProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_GetUCProperty(JSContext* cx, JS::HandleObject obj,
                                            const char16_t* name, size_t namelen,
                                            JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API bool JS_GetElement(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_GetElement(JSContext* cx, JS::HandleObject obj,
                                         uint32_t index,
                                         JS::MutableHandleValue vp);
 
@@ -2844,7 +2844,7 @@ extern JS_PUBLIC_API bool JS_GetElement(JSContext* cx, JS::HandleObject obj,
  *
  * Implements: ES6 [[Set]] internal method.
  */
-extern JS_PUBLIC_API bool JS_ForwardSetPropertyTo(
+extern "C" JS_PUBLIC_API bool JS_ForwardSetPropertyTo(
     JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v,
     JS::HandleValue receiver, JS::ObjectOpResult& result);
 
@@ -2854,19 +2854,19 @@ extern JS_PUBLIC_API bool JS_ForwardSetPropertyTo(
  * This function performs non-strict assignment, so if the property is
  * read-only, nothing happens and no error is thrown.
  */
-extern JS_PUBLIC_API bool JS_SetPropertyById(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_SetPropertyById(JSContext* cx,
                                              JS::HandleObject obj,
                                              JS::HandleId id,
                                              JS::HandleValue v);
 
-extern JS_PUBLIC_API bool JS_SetProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_SetProperty(JSContext* cx, JS::HandleObject obj,
                                          const char* name, JS::HandleValue v);
 
-extern JS_PUBLIC_API bool JS_SetUCProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_SetUCProperty(JSContext* cx, JS::HandleObject obj,
                                            const char16_t* name, size_t namelen,
                                            JS::HandleValue v);
 
-extern JS_PUBLIC_API bool JS_SetElement(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_SetElement(JSContext* cx, JS::HandleObject obj,
                                         uint32_t index, JS::HandleValue v);
 
 extern JS_PUBLIC_API bool JS_SetElement(JSContext* cx, JS::HandleObject obj,
@@ -2895,22 +2895,22 @@ extern JS_PUBLIC_API bool JS_SetElement(JSContext* cx, JS::HandleObject obj,
  *
  * Implements: ES6 [[Delete]] internal method.
  */
-extern JS_PUBLIC_API bool JS_DeletePropertyById(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DeletePropertyById(JSContext* cx,
                                                 JS::HandleObject obj,
                                                 JS::HandleId id,
                                                 JS::ObjectOpResult& result);
 
-extern JS_PUBLIC_API bool JS_DeleteProperty(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_DeleteProperty(JSContext* cx, JS::HandleObject obj,
                                             const char* name,
                                             JS::ObjectOpResult& result);
 
-extern JS_PUBLIC_API bool JS_DeleteUCProperty(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DeleteUCProperty(JSContext* cx,
                                               JS::HandleObject obj,
                                               const char16_t* name,
                                               size_t namelen,
                                               JS::ObjectOpResult& result);
 
-extern JS_PUBLIC_API bool JS_DeleteElement(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_DeleteElement(JSContext* cx, JS::HandleObject obj,
                                            uint32_t index,
                                            JS::ObjectOpResult& result);
 
@@ -2942,7 +2942,7 @@ extern JS_PUBLIC_API bool JS_DeleteElement(JSContext* cx, JS::HandleObject obj,
  * The array of ids returned by JS_Enumerate must be rooted to protect its
  * contents from garbage collection. Use JS::Rooted<JS::IdVector>.
  */
-extern JS_PUBLIC_API bool JS_Enumerate(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_Enumerate(JSContext* cx, JS::HandleObject obj,
                                        JS::MutableHandle<JS::IdVector> props);
 
 /*
@@ -2986,13 +2986,13 @@ extern JS_PUBLIC_API bool IsConstructor(JSObject* obj);
  * Implements: ES6 7.3.12 Call(F, V, [argumentsList]).
  * Use this function to invoke the [[Call]] internal method.
  */
-extern JS_PUBLIC_API bool JS_CallFunctionValue(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_CallFunctionValue(JSContext* cx,
                                                JS::HandleObject obj,
                                                JS::HandleValue fval,
                                                const JS::HandleValueArray& args,
                                                JS::MutableHandleValue rval);
 
-extern JS_PUBLIC_API bool JS_CallFunction(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_CallFunction(JSContext* cx, JS::HandleObject obj,
                                           JS::HandleFunction fun,
                                           const JS::HandleValueArray& args,
                                           JS::MutableHandleValue rval);
@@ -3000,7 +3000,7 @@ extern JS_PUBLIC_API bool JS_CallFunction(JSContext* cx, JS::HandleObject obj,
 /**
  * Perform the method call `rval = obj[name](args)`.
  */
-extern JS_PUBLIC_API bool JS_CallFunctionName(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_CallFunctionName(JSContext* cx,
                                               JS::HandleObject obj,
                                               const char* name,
                                               const JS::HandleValueArray& args,
@@ -3075,55 +3075,55 @@ extern JS_PUBLIC_API bool Construct(JSContext* cx, JS::HandleValue fun,
  * Invoke a constructor, like the JS expression `new ctor(...args)`. Returns
  * the new object, or null on error.
  */
-extern JS_PUBLIC_API JSObject* JS_New(JSContext* cx, JS::HandleObject ctor,
+extern "C" JS_PUBLIC_API JSObject* JS_New(JSContext* cx, JS::HandleObject ctor,
                                       const JS::HandleValueArray& args);
 
 /*** Other property-defining functions **************************************/
 
-extern JS_PUBLIC_API JSObject* JS_DefineObject(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_DefineObject(JSContext* cx,
                                                JS::HandleObject obj,
                                                const char* name,
                                                const JSClass* clasp = nullptr,
                                                unsigned attrs = 0);
 
-extern JS_PUBLIC_API bool JS_DefineConstDoubles(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DefineConstDoubles(JSContext* cx,
                                                 JS::HandleObject obj,
                                                 const JSConstDoubleSpec* cds);
 
-extern JS_PUBLIC_API bool JS_DefineConstIntegers(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DefineConstIntegers(JSContext* cx,
                                                  JS::HandleObject obj,
                                                  const JSConstIntegerSpec* cis);
 
-extern JS_PUBLIC_API bool JS_DefineProperties(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DefineProperties(JSContext* cx,
                                               JS::HandleObject obj,
                                               const JSPropertySpec* ps);
 
 /* * */
 
-extern JS_PUBLIC_API bool JS_AlreadyHasOwnPropertyById(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_AlreadyHasOwnPropertyById(JSContext* cx,
                                                        JS::HandleObject obj,
                                                        JS::HandleId id,
                                                        bool* foundp);
 
-extern JS_PUBLIC_API bool JS_AlreadyHasOwnProperty(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_AlreadyHasOwnProperty(JSContext* cx,
                                                    JS::HandleObject obj,
                                                    const char* name,
                                                    bool* foundp);
 
-extern JS_PUBLIC_API bool JS_AlreadyHasOwnUCProperty(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_AlreadyHasOwnUCProperty(JSContext* cx,
                                                      JS::HandleObject obj,
                                                      const char16_t* name,
                                                      size_t namelen,
                                                      bool* foundp);
 
-extern JS_PUBLIC_API bool JS_AlreadyHasOwnElement(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_AlreadyHasOwnElement(JSContext* cx,
                                                   JS::HandleObject obj,
                                                   uint32_t index, bool* foundp);
 
 extern JS_PUBLIC_API JSObject* JS_NewArrayObject(
     JSContext* cx, const JS::HandleValueArray& contents);
 
-extern JS_PUBLIC_API JSObject* JS_NewArrayObject(JSContext* cx, size_t length);
+extern "C" JS_PUBLIC_API JSObject* JS_NewArrayObject(JSContext* cx, size_t length);
 
 /**
  * Returns true and sets |*isArray| indicating whether |value| is an Array
@@ -3142,14 +3142,14 @@ extern JS_PUBLIC_API bool JS_IsArrayObject(JSContext* cx, JS::HandleValue value,
  * This method returns true with |*isArray == false| when passed a proxy whose
  * target is an Array, or when passed a revoked proxy.
  */
-extern JS_PUBLIC_API bool JS_IsArrayObject(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_IsArrayObject(JSContext* cx, JS::HandleObject obj,
                                            bool* isArray);
 
-extern JS_PUBLIC_API bool JS_GetArrayLength(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_GetArrayLength(JSContext* cx,
                                             JS::Handle<JSObject*> obj,
                                             uint32_t* lengthp);
 
-extern JS_PUBLIC_API bool JS_SetArrayLength(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_SetArrayLength(JSContext* cx,
                                             JS::Handle<JSObject*> obj,
                                             uint32_t length);
 
@@ -3189,7 +3189,7 @@ JS_PUBLIC_API void JS_SetAllNonReservedSlotsToUndefined(JSContext* cx,
  * these contents to free(). On success, the ownership is transferred to the
  * new array buffer.
  */
-extern JS_PUBLIC_API JSObject* JS_NewArrayBufferWithContents(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_NewArrayBufferWithContents(JSContext* cx,
                                                              size_t nbytes,
                                                              void* contents);
 
@@ -3233,7 +3233,7 @@ extern JS_PUBLIC_API JSObject* JS_NewExternalArrayBuffer(
  * take ownership of contents, and JS_DetachArrayBuffer must be called before
  * the contents are disposed of.
  */
-extern JS_PUBLIC_API JSObject* JS_NewArrayBufferWithExternalContents(
+extern "C" JS_PUBLIC_API JSObject* JS_NewArrayBufferWithExternalContents(
     JSContext* cx, size_t nbytes, void* contents);
 
 /**
@@ -3242,7 +3242,7 @@ extern JS_PUBLIC_API JSObject* JS_NewArrayBufferWithExternalContents(
  * of the return value and must free it or transfer ownership via
  * JS_NewArrayBufferWithContents when done using it.
  */
-extern JS_PUBLIC_API void* JS_StealArrayBufferContents(JSContext* cx,
+extern "C" JS_PUBLIC_API void* JS_StealArrayBufferContents(JSContext* cx,
                                                        JS::HandleObject obj);
 
 /**
@@ -3264,7 +3264,7 @@ extern JS_PUBLIC_API void* JS_StealArrayBufferContents(JSContext* cx,
  * If |obj| isn't an ArrayBuffer, this function returns null and reports an
  * error.
  */
-extern JS_PUBLIC_API void* JS_ExternalizeArrayBufferContents(
+extern "C" JS_PUBLIC_API void* JS_ExternalizeArrayBufferContents(
     JSContext* cx, JS::HandleObject obj);
 
 /**
@@ -3272,14 +3272,14 @@ extern JS_PUBLIC_API void* JS_ExternalizeArrayBufferContents(
  * must be legal to free the contents pointer by unmapping it. On success,
  * ownership is transferred to the new mapped array buffer.
  */
-extern JS_PUBLIC_API JSObject* JS_NewMappedArrayBufferWithContents(
+extern "C" JS_PUBLIC_API JSObject* JS_NewMappedArrayBufferWithContents(
     JSContext* cx, size_t nbytes, void* contents);
 
 /**
  * Create memory mapped array buffer contents.
  * Caller must take care of closing fd after calling this function.
  */
-extern JS_PUBLIC_API void* JS_CreateMappedArrayBufferContents(int fd,
+extern "C" JS_PUBLIC_API void* JS_CreateMappedArrayBufferContents(int fd,
                                                               size_t offset,
                                                               size_t length);
 
@@ -3290,13 +3290,13 @@ extern JS_PUBLIC_API void* JS_CreateMappedArrayBufferContents(int fd,
  * with this content, then JS_DetachArrayBuffer() should be used instead to
  * release the resource used by the object.
  */
-extern JS_PUBLIC_API void JS_ReleaseMappedArrayBufferContents(void* contents,
+extern "C" JS_PUBLIC_API void JS_ReleaseMappedArrayBufferContents(void* contents,
                                                               size_t length);
 
-extern JS_PUBLIC_API JS::Value JS_GetReservedSlot(JSObject* obj,
+extern "C" JS_PUBLIC_API JS::Value JS_GetReservedSlot(JSObject* obj,
                                                   uint32_t index);
 
-extern JS_PUBLIC_API void JS_SetReservedSlot(JSObject* obj, uint32_t index,
+extern "C" JS_PUBLIC_API void JS_SetReservedSlot(JSObject* obj, uint32_t index,
                                              const JS::Value& v);
 
 /************************************************************************/
@@ -3304,7 +3304,7 @@ extern JS_PUBLIC_API void JS_SetReservedSlot(JSObject* obj, uint32_t index,
 /*
  * Functions and scripts.
  */
-extern JS_PUBLIC_API JSFunction* JS_NewFunction(JSContext* cx, JSNative call,
+extern "C" JS_PUBLIC_API JSFunction* JS_NewFunction(JSContext* cx, JSNative call,
                                                 unsigned nargs, unsigned flags,
                                                 const char* name);
 
@@ -3327,7 +3327,7 @@ extern JS_PUBLIC_API JSFunction* NewFunctionFromSpec(JSContext* cx,
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API JSObject* JS_GetFunctionObject(JSFunction* fun);
+extern "C" JS_PUBLIC_API JSObject* JS_GetFunctionObject(JSFunction* fun);
 
 /**
  * Return the function's identifier as a JSString, or null if fun is unnamed.
@@ -3335,7 +3335,7 @@ extern JS_PUBLIC_API JSObject* JS_GetFunctionObject(JSFunction* fun);
  * reference to it if fun is well-connected or rooted, and provided you bound
  * the use of the saved reference by fun's lifetime.
  */
-extern JS_PUBLIC_API JSString* JS_GetFunctionId(JSFunction* fun);
+extern "C" JS_PUBLIC_API JSString* JS_GetFunctionId(JSFunction* fun);
 
 /**
  * Return a function's display name. This is the defined name if one was given
@@ -3344,12 +3344,12 @@ extern JS_PUBLIC_API JSString* JS_GetFunctionId(JSFunction* fun);
  * still return nullptr if a useful display name could not be inferred. The
  * same restrictions on rooting as those in JS_GetFunctionId apply.
  */
-extern JS_PUBLIC_API JSString* JS_GetFunctionDisplayId(JSFunction* fun);
+extern "C" JS_PUBLIC_API JSString* JS_GetFunctionDisplayId(JSFunction* fun);
 
 /*
  * Return the arity (length) of fun.
  */
-extern JS_PUBLIC_API uint16_t JS_GetFunctionArity(JSFunction* fun);
+extern "C" JS_PUBLIC_API uint16_t JS_GetFunctionArity(JSFunction* fun);
 
 /**
  * Infallible predicate to test whether obj is a function object (faster than
@@ -3357,32 +3357,32 @@ extern JS_PUBLIC_API uint16_t JS_GetFunctionArity(JSFunction* fun);
  * overwritten the "Function" identifier with a different constructor and then
  * created instances using that constructor that might be passed in as obj).
  */
-extern JS_PUBLIC_API bool JS_ObjectIsFunction(JSContext* cx, JSObject* obj);
+extern "C" JS_PUBLIC_API bool JS_ObjectIsFunction(JSContext* cx, JSObject* obj);
 
-extern JS_PUBLIC_API bool JS_IsNativeFunction(JSObject* funobj, JSNative call);
+extern "C" JS_PUBLIC_API bool JS_IsNativeFunction(JSObject* funobj, JSNative call);
 
 /** Return whether the given function is a valid constructor. */
-extern JS_PUBLIC_API bool JS_IsConstructor(JSFunction* fun);
+extern "C" JS_PUBLIC_API bool JS_IsConstructor(JSFunction* fun);
 
-extern JS_PUBLIC_API bool JS_DefineFunctions(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_DefineFunctions(JSContext* cx,
                                              JS::Handle<JSObject*> obj,
                                              const JSFunctionSpec* fs);
 
-extern JS_PUBLIC_API JSFunction* JS_DefineFunction(
+extern "C" JS_PUBLIC_API JSFunction* JS_DefineFunction(
     JSContext* cx, JS::Handle<JSObject*> obj, const char* name, JSNative call,
     unsigned nargs, unsigned attrs);
 
-extern JS_PUBLIC_API JSFunction* JS_DefineUCFunction(
+extern "C" JS_PUBLIC_API JSFunction* JS_DefineUCFunction(
     JSContext* cx, JS::Handle<JSObject*> obj, const char16_t* name,
     size_t namelen, JSNative call, unsigned nargs, unsigned attrs);
 
-extern JS_PUBLIC_API JSFunction* JS_DefineFunctionById(
+extern "C" JS_PUBLIC_API JSFunction* JS_DefineFunctionById(
     JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id,
     JSNative call, unsigned nargs, unsigned attrs);
 
-extern JS_PUBLIC_API bool JS_IsFunctionBound(JSFunction* fun);
+extern "C" JS_PUBLIC_API bool JS_IsFunctionBound(JSFunction* fun);
 
-extern JS_PUBLIC_API JSObject* JS_GetBoundFunctionTarget(JSFunction* fun);
+extern "C" JS_PUBLIC_API JSObject* JS_GetBoundFunctionTarget(JSFunction* fun);
 
 namespace JS {
 
@@ -3410,7 +3410,7 @@ extern JS_PUBLIC_API JSObject* CloneFunctionObject(
  * lines in a buffer until JS_BufferIsCompilableUnit is true, then pass it to
  * the compiler.
  */
-extern JS_PUBLIC_API bool JS_BufferIsCompilableUnit(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_BufferIsCompilableUnit(JSContext* cx,
                                                     JS::Handle<JSObject*> obj,
                                                     const char* utf8,
                                                     size_t length);
@@ -3418,7 +3418,7 @@ extern JS_PUBLIC_API bool JS_BufferIsCompilableUnit(JSContext* cx,
 /**
  * |script| will always be set. On failure, it will be set to nullptr.
  */
-extern JS_PUBLIC_API bool JS_CompileScript(JSContext* cx, const char* ascii,
+extern "C" JS_PUBLIC_API bool JS_CompileScript(JSContext* cx, const char* ascii,
                                            size_t length,
                                            const JS::CompileOptions& options,
                                            JS::MutableHandleScript script);
@@ -3426,20 +3426,20 @@ extern JS_PUBLIC_API bool JS_CompileScript(JSContext* cx, const char* ascii,
 /**
  * |script| will always be set. On failure, it will be set to nullptr.
  */
-extern JS_PUBLIC_API bool JS_CompileUCScript(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_CompileUCScript(JSContext* cx,
                                              const char16_t* chars,
                                              size_t length,
                                              const JS::CompileOptions& options,
                                              JS::MutableHandleScript script);
 
-extern JS_PUBLIC_API JSObject* JS_GetGlobalFromScript(JSScript* script);
+extern "C" JS_PUBLIC_API JSObject* JS_GetGlobalFromScript(JSScript* script);
 
-extern JS_PUBLIC_API const char* JS_GetScriptFilename(JSScript* script);
+extern "C" JS_PUBLIC_API const char* JS_GetScriptFilename(JSScript* script);
 
-extern JS_PUBLIC_API unsigned JS_GetScriptBaseLineNumber(JSContext* cx,
+extern "C" JS_PUBLIC_API unsigned JS_GetScriptBaseLineNumber(JSContext* cx,
                                                          JSScript* script);
 
-extern JS_PUBLIC_API JSScript* JS_GetFunctionScript(JSContext* cx,
+extern "C" JS_PUBLIC_API JSScript* JS_GetFunctionScript(JSContext* cx,
                                                     JS::HandleFunction fun);
 
 namespace JS {
@@ -4075,10 +4075,10 @@ extern JS_PUBLIC_API void ExposeScriptToDebugger(JSContext* cx,
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API JSString* JS_DecompileScript(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_DecompileScript(JSContext* cx,
                                                   JS::Handle<JSScript*> script);
 
-extern JS_PUBLIC_API JSString* JS_DecompileFunction(
+extern "C" JS_PUBLIC_API JSString* JS_DecompileFunction(
     JSContext* cx, JS::Handle<JSFunction*> fun);
 
 /*
@@ -4101,7 +4101,7 @@ extern JS_PUBLIC_API JSString* JS_DecompileFunction(
 /**
  * Evaluate a script in the scope of the current global of cx.
  */
-extern JS_PUBLIC_API bool JS_ExecuteScript(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_ExecuteScript(JSContext* cx,
                                            JS::HandleScript script,
                                            JS::MutableHandleValue rval);
 
@@ -4283,7 +4283,7 @@ extern JS_PUBLIC_API JSScript* GetModuleScript(JS::HandleObject moduleRecord);
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API bool JS_CheckForInterrupt(JSContext* cx);
+extern "C" JS_PUBLIC_API bool JS_CheckForInterrupt(JSContext* cx);
 
 /*
  * These functions allow setting an interrupt callback that will be called
@@ -4298,14 +4298,14 @@ extern JS_PUBLIC_API bool JS_CheckForInterrupt(JSContext* cx);
  * if it re-enters the JS engine. The embedding must ensure that the callback
  * is disconnected before attempting such re-entry.
  */
-extern JS_PUBLIC_API bool JS_AddInterruptCallback(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_AddInterruptCallback(JSContext* cx,
                                                   JSInterruptCallback callback);
 
-extern JS_PUBLIC_API bool JS_DisableInterruptCallback(JSContext* cx);
+extern "C" JS_PUBLIC_API bool JS_DisableInterruptCallback(JSContext* cx);
 
-extern JS_PUBLIC_API void JS_ResetInterruptCallback(JSContext* cx, bool enable);
+extern "C" JS_PUBLIC_API void JS_ResetInterruptCallback(JSContext* cx, bool enable);
 
-extern JS_PUBLIC_API void JS_RequestInterruptCallback(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_RequestInterruptCallback(JSContext* cx);
 
 extern JS_PUBLIC_API void JS_RequestInterruptCallbackCanWait(JSContext* cx);
 
@@ -4694,71 +4694,71 @@ class MOZ_STACK_CLASS JS_PUBLIC_API AutoSetAsyncStackForNewCalls {
  * for them. In contrast, all the JS_New*StringCopy* functions do not take
  * ownership of the character memory passed to them -- they copy it.
  */
-extern JS_PUBLIC_API JSString* JS_NewStringCopyN(JSContext* cx, const char* s,
+extern "C" JS_PUBLIC_API JSString* JS_NewStringCopyN(JSContext* cx, const char* s,
                                                  size_t n);
 
-extern JS_PUBLIC_API JSString* JS_NewStringCopyZ(JSContext* cx, const char* s);
+extern "C" JS_PUBLIC_API JSString* JS_NewStringCopyZ(JSContext* cx, const char* s);
 
-extern JS_PUBLIC_API JSString* JS_NewStringCopyUTF8Z(
+extern "C" JS_PUBLIC_API JSString* JS_NewStringCopyUTF8Z(
     JSContext* cx, const JS::ConstUTF8CharsZ s);
 
-extern JS_PUBLIC_API JSString* JS_NewStringCopyUTF8N(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_NewStringCopyUTF8N(JSContext* cx,
                                                      const JS::UTF8Chars s);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeAndPinJSString(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeAndPinJSString(JSContext* cx,
                                                         JS::HandleString str);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeStringN(JSContext* cx, const char* s,
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeStringN(JSContext* cx, const char* s,
                                                  size_t length);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeString(JSContext* cx, const char* s);
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeString(JSContext* cx, const char* s);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeAndPinStringN(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeAndPinStringN(JSContext* cx,
                                                        const char* s,
                                                        size_t length);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeAndPinString(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeAndPinString(JSContext* cx,
                                                       const char* s);
 
 extern JS_PUBLIC_API JSString* JS_NewLatin1String(JSContext* cx,
                                                   JS::Latin1Char* chars,
                                                   size_t length);
 
-extern JS_PUBLIC_API JSString* JS_NewUCString(JSContext* cx, char16_t* chars,
+extern "C" JS_PUBLIC_API JSString* JS_NewUCString(JSContext* cx, char16_t* chars,
                                               size_t length);
 
-extern JS_PUBLIC_API JSString* JS_NewUCStringCopyN(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_NewUCStringCopyN(JSContext* cx,
                                                    const char16_t* s, size_t n);
 
-extern JS_PUBLIC_API JSString* JS_NewUCStringCopyZ(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_NewUCStringCopyZ(JSContext* cx,
                                                    const char16_t* s);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeUCStringN(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeUCStringN(JSContext* cx,
                                                    const char16_t* s,
                                                    size_t length);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeUCString(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeUCString(JSContext* cx,
                                                   const char16_t* s);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeAndPinUCStringN(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeAndPinUCStringN(JSContext* cx,
                                                          const char16_t* s,
                                                          size_t length);
 
-extern JS_PUBLIC_API JSString* JS_AtomizeAndPinUCString(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_AtomizeAndPinUCString(JSContext* cx,
                                                         const char16_t* s);
 
-extern JS_PUBLIC_API bool JS_CompareStrings(JSContext* cx, JSString* str1,
+extern "C" JS_PUBLIC_API bool JS_CompareStrings(JSContext* cx, JSString* str1,
                                             JSString* str2, int32_t* result);
 
-extern JS_PUBLIC_API bool JS_StringEqualsAscii(JSContext* cx, JSString* str,
+extern "C" JS_PUBLIC_API bool JS_StringEqualsAscii(JSContext* cx, JSString* str,
                                                const char* asciiBytes,
                                                bool* match);
 
-extern JS_PUBLIC_API size_t JS_PutEscapedString(JSContext* cx, char* buffer,
+extern "C" JS_PUBLIC_API size_t JS_PutEscapedString(JSContext* cx, char* buffer,
                                                 size_t size, JSString* str,
                                                 char quote);
 
-extern JS_PUBLIC_API bool JS_FileEscapedString(FILE* fp, JSString* str,
+extern "C" JS_PUBLIC_API bool JS_FileEscapedString(FILE* fp, JSString* str,
                                                char quote);
 
 /*
@@ -4800,41 +4800,41 @@ extern JS_PUBLIC_API bool JS_FileEscapedString(FILE* fp, JSString* str,
  * strings.
  */
 
-extern JS_PUBLIC_API size_t JS_GetStringLength(JSString* str);
+extern "C" JS_PUBLIC_API size_t JS_GetStringLength(JSString* str);
 
-extern JS_PUBLIC_API bool JS_StringIsFlat(JSString* str);
+extern "C" JS_PUBLIC_API bool JS_StringIsFlat(JSString* str);
 
 /** Returns true iff the string's characters are stored as Latin1. */
-extern JS_PUBLIC_API bool JS_StringHasLatin1Chars(JSString* str);
+extern "C" JS_PUBLIC_API bool JS_StringHasLatin1Chars(JSString* str);
 
-extern JS_PUBLIC_API const JS::Latin1Char* JS_GetLatin1StringCharsAndLength(
+extern "C" JS_PUBLIC_API const JS::Latin1Char* JS_GetLatin1StringCharsAndLength(
     JSContext* cx, const JS::AutoRequireNoGC& nogc, JSString* str,
     size_t* length);
 
-extern JS_PUBLIC_API const char16_t* JS_GetTwoByteStringCharsAndLength(
+extern "C" JS_PUBLIC_API const char16_t* JS_GetTwoByteStringCharsAndLength(
     JSContext* cx, const JS::AutoRequireNoGC& nogc, JSString* str,
     size_t* length);
 
-extern JS_PUBLIC_API bool JS_GetStringCharAt(JSContext* cx, JSString* str,
+extern "C" JS_PUBLIC_API bool JS_GetStringCharAt(JSContext* cx, JSString* str,
                                              size_t index, char16_t* res);
 
-extern JS_PUBLIC_API char16_t JS_GetFlatStringCharAt(JSFlatString* str,
+extern "C" JS_PUBLIC_API char16_t JS_GetFlatStringCharAt(JSFlatString* str,
                                                      size_t index);
 
-extern JS_PUBLIC_API const char16_t* JS_GetTwoByteExternalStringChars(
+extern "C" JS_PUBLIC_API const char16_t* JS_GetTwoByteExternalStringChars(
     JSString* str);
 
-extern JS_PUBLIC_API bool JS_CopyStringChars(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_CopyStringChars(JSContext* cx,
                                              mozilla::Range<char16_t> dest,
                                              JSString* str);
 
-extern JS_PUBLIC_API JSFlatString* JS_FlattenString(JSContext* cx,
+extern "C" JS_PUBLIC_API JSFlatString* JS_FlattenString(JSContext* cx,
                                                     JSString* str);
 
-extern JS_PUBLIC_API const JS::Latin1Char* JS_GetLatin1FlatStringChars(
+extern "C" JS_PUBLIC_API const JS::Latin1Char* JS_GetLatin1FlatStringChars(
     const JS::AutoRequireNoGC& nogc, JSFlatString* str);
 
-extern JS_PUBLIC_API const char16_t* JS_GetTwoByteFlatStringChars(
+extern "C" JS_PUBLIC_API const char16_t* JS_GetTwoByteFlatStringChars(
     const JS::AutoRequireNoGC& nogc, JSFlatString* str);
 
 static MOZ_ALWAYS_INLINE JSFlatString* JSID_TO_FLAT_STRING(jsid id) {
@@ -5106,7 +5106,7 @@ typedef bool (*JSONWriteCallback)(const char16_t* buf, uint32_t len,
 /**
  * JSON.stringify as specified by ES5.
  */
-JS_PUBLIC_API bool JS_Stringify(JSContext* cx, JS::MutableHandleValue value,
+extern "C" JS_PUBLIC_API bool JS_Stringify(JSContext* cx, JS::MutableHandleValue value,
                                 JS::HandleObject replacer,
                                 JS::HandleValue space,
                                 JSONWriteCallback callback, void* data);
@@ -5138,7 +5138,7 @@ JS_PUBLIC_API bool ToJSONMaybeSafely(JSContext* cx, JS::HandleObject input,
 /**
  * JSON.parse as specified by ES5.
  */
-JS_PUBLIC_API bool JS_ParseJSON(JSContext* cx, const char16_t* chars,
+extern "C" JS_PUBLIC_API bool JS_ParseJSON(JSContext* cx, const char16_t* chars,
                                 uint32_t len, JS::MutableHandleValue vp);
 
 JS_PUBLIC_API bool JS_ParseJSON(JSContext* cx, JS::HandleString str,
@@ -5162,7 +5162,7 @@ JS_PUBLIC_API bool JS_ParseJSONWithReviver(JSContext* cx, JS::HandleString str,
  * specify their own locales.
  * The locale string remains owned by the caller.
  */
-extern JS_PUBLIC_API bool JS_SetDefaultLocale(JSRuntime* rt,
+extern "C" JS_PUBLIC_API bool JS_SetDefaultLocale(JSRuntime* rt,
                                               const char* locale);
 
 /**
@@ -5174,7 +5174,7 @@ extern JS_PUBLIC_API JS::UniqueChars JS_GetDefaultLocale(JSContext* cx);
 /**
  * Reset the default locale to OS defaults.
  */
-extern JS_PUBLIC_API void JS_ResetDefaultLocale(JSRuntime* rt);
+extern "C" JS_PUBLIC_API void JS_ResetDefaultLocale(JSRuntime* rt);
 
 /**
  * Locale specific string conversion and error message callbacks.
@@ -5190,14 +5190,14 @@ struct JSLocaleCallbacks {
  * Establish locale callbacks. The pointer must persist as long as the
  * JSContext.  Passing nullptr restores the default behaviour.
  */
-extern JS_PUBLIC_API void JS_SetLocaleCallbacks(
+extern "C" JS_PUBLIC_API void JS_SetLocaleCallbacks(
     JSRuntime* rt, const JSLocaleCallbacks* callbacks);
 
 /**
  * Return the address of the current locale callbacks struct, which may
  * be nullptr.
  */
-extern JS_PUBLIC_API const JSLocaleCallbacks* JS_GetLocaleCallbacks(
+extern "C" JS_PUBLIC_API const JSLocaleCallbacks* JS_GetLocaleCallbacks(
     JSRuntime* rt);
 
 /************************************************************************/
@@ -5236,43 +5236,43 @@ const uint16_t MaxNumErrorArguments = 10;
  * Report an exception represented by the sprintf-like conversion of format
  * and its arguments.
  */
-extern JS_PUBLIC_API void JS_ReportErrorASCII(JSContext* cx, const char* format,
+extern "C" JS_PUBLIC_API void JS_ReportErrorASCII(JSContext* cx, const char* format,
                                               ...) MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API void JS_ReportErrorLatin1(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_ReportErrorLatin1(JSContext* cx,
                                                const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API void JS_ReportErrorUTF8(JSContext* cx, const char* format,
+extern "C" JS_PUBLIC_API void JS_ReportErrorUTF8(JSContext* cx, const char* format,
                                              ...) MOZ_FORMAT_PRINTF(2, 3);
 
 /*
  * Use an errorNumber to retrieve the format string, args are char*
  */
-extern JS_PUBLIC_API void JS_ReportErrorNumberASCII(
+extern "C" JS_PUBLIC_API void JS_ReportErrorNumberASCII(
     JSContext* cx, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API void JS_ReportErrorNumberASCIIVA(
+extern "C" JS_PUBLIC_API void JS_ReportErrorNumberASCIIVA(
     JSContext* cx, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, va_list ap);
 
-extern JS_PUBLIC_API void JS_ReportErrorNumberLatin1(
+extern "C" JS_PUBLIC_API void JS_ReportErrorNumberLatin1(
     JSContext* cx, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, ...);
 
 #ifdef va_start
-extern JS_PUBLIC_API void JS_ReportErrorNumberLatin1VA(
+extern "C" JS_PUBLIC_API void JS_ReportErrorNumberLatin1VA(
     JSContext* cx, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, va_list ap);
 #endif
 
-extern JS_PUBLIC_API void JS_ReportErrorNumberUTF8(
+extern "C" JS_PUBLIC_API void JS_ReportErrorNumberUTF8(
     JSContext* cx, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, ...);
 
 #ifdef va_start
-extern JS_PUBLIC_API void JS_ReportErrorNumberUTF8VA(
+extern "C" JS_PUBLIC_API void JS_ReportErrorNumberUTF8VA(
     JSContext* cx, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, va_list ap);
 #endif
@@ -5280,13 +5280,13 @@ extern JS_PUBLIC_API void JS_ReportErrorNumberUTF8VA(
 /*
  * Use an errorNumber to retrieve the format string, args are char16_t*
  */
-extern JS_PUBLIC_API void JS_ReportErrorNumberUC(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_ReportErrorNumberUC(JSContext* cx,
                                                  JSErrorCallback errorCallback,
                                                  void* userRef,
                                                  const unsigned errorNumber,
                                                  ...);
 
-extern JS_PUBLIC_API void JS_ReportErrorNumberUCArray(
+extern "C" JS_PUBLIC_API void JS_ReportErrorNumberUCArray(
     JSContext* cx, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, const char16_t** args);
 
@@ -5296,43 +5296,43 @@ extern JS_PUBLIC_API void JS_ReportErrorNumberUCArray(
  * warning was not converted into an error due to the JSOPTION_WERROR option
  * being set, false otherwise.
  */
-extern JS_PUBLIC_API bool JS_ReportWarningASCII(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_ReportWarningASCII(JSContext* cx,
                                                 const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API bool JS_ReportWarningLatin1(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_ReportWarningLatin1(JSContext* cx,
                                                  const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API bool JS_ReportWarningUTF8(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_ReportWarningUTF8(JSContext* cx,
                                                const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API bool JS_ReportErrorFlagsAndNumberASCII(
+extern "C" JS_PUBLIC_API bool JS_ReportErrorFlagsAndNumberASCII(
     JSContext* cx, unsigned flags, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API bool JS_ReportErrorFlagsAndNumberLatin1(
+extern "C" JS_PUBLIC_API bool JS_ReportErrorFlagsAndNumberLatin1(
     JSContext* cx, unsigned flags, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API bool JS_ReportErrorFlagsAndNumberUTF8(
+extern "C" JS_PUBLIC_API bool JS_ReportErrorFlagsAndNumberUTF8(
     JSContext* cx, unsigned flags, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API bool JS_ReportErrorFlagsAndNumberUC(
+extern "C" JS_PUBLIC_API bool JS_ReportErrorFlagsAndNumberUC(
     JSContext* cx, unsigned flags, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, ...);
 
 /**
  * Complain when out of memory.
  */
-extern JS_PUBLIC_API void JS_ReportOutOfMemory(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_ReportOutOfMemory(JSContext* cx);
 
 /**
  * Complain when an allocation size overflows the maximum supported limit.
  */
-extern JS_PUBLIC_API void JS_ReportAllocationOverflow(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_ReportAllocationOverflow(JSContext* cx);
 
 /**
  * Base class that implements parts shared by JSErrorReport and
@@ -5519,10 +5519,10 @@ namespace JS {
 
 using WarningReporter = void (*)(JSContext* cx, JSErrorReport* report);
 
-extern JS_PUBLIC_API WarningReporter
+extern "C" JS_PUBLIC_API WarningReporter
 SetWarningReporter(JSContext* cx, WarningReporter reporter);
 
-extern JS_PUBLIC_API WarningReporter GetWarningReporter(JSContext* cx);
+extern "C" JS_PUBLIC_API WarningReporter GetWarningReporter(JSContext* cx);
 
 extern JS_PUBLIC_API bool CreateError(
     JSContext* cx, JSExnType type, HandleObject stack, HandleString fileName,
@@ -5620,7 +5620,7 @@ extern JS_PUBLIC_API bool SetForEach(JSContext* cx, HandleObject obj,
  * Dates.
  */
 
-extern JS_PUBLIC_API JSObject* JS_NewDateObject(JSContext* cx, int year,
+extern "C" JS_PUBLIC_API JSObject* JS_NewDateObject(JSContext* cx, int year,
                                                 int mon, int mday, int hour,
                                                 int min, int sec);
 
@@ -5631,7 +5631,7 @@ extern JS_PUBLIC_API JSObject* JS_NewDateObject(JSContext* cx, int year,
  * This method returns true with |*isDate == false| when passed a proxy whose
  * target is a Date, or when passed a revoked proxy.
  */
-extern JS_PUBLIC_API bool JS_ObjectIsDate(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_ObjectIsDate(JSContext* cx, JS::HandleObject obj,
                                           bool* isDate);
 
 /************************************************************************/
@@ -5645,23 +5645,23 @@ extern JS_PUBLIC_API bool JS_ObjectIsDate(JSContext* cx, JS::HandleObject obj,
 #define JSREG_STICKY 0x08u    /* only match starting at lastIndex */
 #define JSREG_UNICODE 0x10u   /* unicode */
 
-extern JS_PUBLIC_API JSObject* JS_NewRegExpObject(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_NewRegExpObject(JSContext* cx,
                                                   const char* bytes,
                                                   size_t length,
                                                   unsigned flags);
 
-extern JS_PUBLIC_API JSObject* JS_NewUCRegExpObject(JSContext* cx,
+extern "C" JS_PUBLIC_API JSObject* JS_NewUCRegExpObject(JSContext* cx,
                                                     const char16_t* chars,
                                                     size_t length,
                                                     unsigned flags);
 
-extern JS_PUBLIC_API bool JS_SetRegExpInput(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_SetRegExpInput(JSContext* cx, JS::HandleObject obj,
                                             JS::HandleString input);
 
-extern JS_PUBLIC_API bool JS_ClearRegExpStatics(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_ClearRegExpStatics(JSContext* cx,
                                                 JS::HandleObject obj);
 
-extern JS_PUBLIC_API bool JS_ExecuteRegExp(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_ExecuteRegExp(JSContext* cx, JS::HandleObject obj,
                                            JS::HandleObject reobj,
                                            char16_t* chars, size_t length,
                                            size_t* indexp, bool test,
@@ -5669,7 +5669,7 @@ extern JS_PUBLIC_API bool JS_ExecuteRegExp(JSContext* cx, JS::HandleObject obj,
 
 /* RegExp interface for clients without a global object. */
 
-extern JS_PUBLIC_API bool JS_ExecuteRegExpNoStatics(
+extern "C" JS_PUBLIC_API bool JS_ExecuteRegExpNoStatics(
     JSContext* cx, JS::HandleObject reobj, char16_t* chars, size_t length,
     size_t* indexp, bool test, JS::MutableHandleValue rval);
 
@@ -5680,26 +5680,26 @@ extern JS_PUBLIC_API bool JS_ExecuteRegExpNoStatics(
  * This method returns true with |*isRegExp == false| when passed a proxy whose
  * target is a RegExp, or when passed a revoked proxy.
  */
-extern JS_PUBLIC_API bool JS_ObjectIsRegExp(JSContext* cx, JS::HandleObject obj,
+extern "C" JS_PUBLIC_API bool JS_ObjectIsRegExp(JSContext* cx, JS::HandleObject obj,
                                             bool* isRegExp);
 
-extern JS_PUBLIC_API unsigned JS_GetRegExpFlags(JSContext* cx,
+extern "C" JS_PUBLIC_API unsigned JS_GetRegExpFlags(JSContext* cx,
                                                 JS::HandleObject obj);
 
-extern JS_PUBLIC_API JSString* JS_GetRegExpSource(JSContext* cx,
+extern "C" JS_PUBLIC_API JSString* JS_GetRegExpSource(JSContext* cx,
                                                   JS::HandleObject obj);
 
 /************************************************************************/
 
-extern JS_PUBLIC_API bool JS_IsExceptionPending(JSContext* cx);
+extern "C" JS_PUBLIC_API bool JS_IsExceptionPending(JSContext* cx);
 
-extern JS_PUBLIC_API bool JS_GetPendingException(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_GetPendingException(JSContext* cx,
                                                  JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API void JS_SetPendingException(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_SetPendingException(JSContext* cx,
                                                  JS::HandleValue v);
 
-extern JS_PUBLIC_API void JS_ClearPendingException(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_ClearPendingException(JSContext* cx);
 
 namespace JS {
 
@@ -5758,12 +5758,12 @@ class JS_PUBLIC_API AutoSaveExceptionState {
 } /* namespace JS */
 
 /* Deprecated API. Use AutoSaveExceptionState instead. */
-extern JS_PUBLIC_API JSExceptionState* JS_SaveExceptionState(JSContext* cx);
+extern "C" JS_PUBLIC_API JSExceptionState* JS_SaveExceptionState(JSContext* cx);
 
-extern JS_PUBLIC_API void JS_RestoreExceptionState(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_RestoreExceptionState(JSContext* cx,
                                                    JSExceptionState* state);
 
-extern JS_PUBLIC_API void JS_DropExceptionState(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_DropExceptionState(JSContext* cx,
                                                 JSExceptionState* state);
 
 /**
@@ -5773,7 +5773,7 @@ extern JS_PUBLIC_API void JS_DropExceptionState(JSContext* cx,
  * of the error report struct that might be returned is the same as the
  * lifetime of the exception object.
  */
-extern JS_PUBLIC_API JSErrorReport* JS_ErrorFromException(JSContext* cx,
+extern "C" JS_PUBLIC_API JSErrorReport* JS_ErrorFromException(JSContext* cx,
                                                           JS::HandleObject obj);
 
 namespace JS {
@@ -5784,7 +5784,7 @@ namespace JS {
  * (including if it's null or a security wrapper that can't be unwrapped) or if
  * the exception has no stack.
  */
-extern JS_PUBLIC_API JSObject* ExceptionStackOrNull(JS::HandleObject obj);
+extern "C" JS_PUBLIC_API JSObject* ExceptionStackOrNull(JS::HandleObject obj);
 
 } /* namespace JS */
 
@@ -5798,7 +5798,7 @@ extern JS_PUBLIC_API JSObject* ExceptionStackOrNull(JS::HandleObject obj);
  * non-debug builds).
  */
 
-extern JS_PUBLIC_API void JS_AbortIfWrongThread(JSContext* cx);
+extern "C" JS_PUBLIC_API void JS_AbortIfWrongThread(JSContext* cx);
 
 /************************************************************************/
 
@@ -5807,7 +5807,7 @@ extern JS_PUBLIC_API void JS_AbortIfWrongThread(JSContext* cx);
  * object of the given class, using the callee to determine parentage and
  * [[Prototype]].
  */
-extern JS_PUBLIC_API JSObject* JS_NewObjectForConstructor(
+extern "C" JS_PUBLIC_API JSObject* JS_NewObjectForConstructor(
     JSContext* cx, const JSClass* clasp, const JS::CallArgs& args);
 
 /************************************************************************/
@@ -5825,10 +5825,10 @@ extern JS_PUBLIC_API void JS_SetGCZeal(JSContext* cx, uint8_t zeal,
 extern JS_PUBLIC_API void JS_ScheduleGC(JSContext* cx, uint32_t count);
 #endif
 
-extern JS_PUBLIC_API void JS_SetParallelParsingEnabled(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_SetParallelParsingEnabled(JSContext* cx,
                                                        bool enabled);
 
-extern JS_PUBLIC_API void JS_SetOffthreadIonCompilationEnabled(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_SetOffthreadIonCompilationEnabled(JSContext* cx,
                                                                bool enabled);
 
 //clang-format off
@@ -5866,17 +5866,17 @@ typedef enum JSJitCompilerOption {
       JSJITCOMPILER_NOT_AN_OPTION
 } JSJitCompilerOption;
 
-extern JS_PUBLIC_API void JS_SetGlobalJitCompilerOption(JSContext* cx,
+extern "C" JS_PUBLIC_API void JS_SetGlobalJitCompilerOption(JSContext* cx,
                                                         JSJitCompilerOption opt,
                                                         uint32_t value);
-extern JS_PUBLIC_API bool JS_GetGlobalJitCompilerOption(JSContext* cx,
+extern "C" JS_PUBLIC_API bool JS_GetGlobalJitCompilerOption(JSContext* cx,
                                                         JSJitCompilerOption opt,
                                                         uint32_t* valueOut);
 
 /**
  * Convert a uint32_t index into a jsid.
  */
-extern JS_PUBLIC_API bool JS_IndexToId(JSContext* cx, uint32_t index,
+extern "C" JS_PUBLIC_API bool JS_IndexToId(JSContext* cx, uint32_t index,
                                        JS::MutableHandleId);
 
 /**
@@ -5884,13 +5884,13 @@ extern JS_PUBLIC_API bool JS_IndexToId(JSContext* cx, uint32_t index,
  *
  * |chars| may not be an index.
  */
-extern JS_PUBLIC_API bool JS_CharsToId(JSContext* cx, JS::TwoByteChars chars,
+extern "C" JS_PUBLIC_API bool JS_CharsToId(JSContext* cx, JS::TwoByteChars chars,
                                        JS::MutableHandleId);
 
 /**
  *  Test if the given string is a valid ECMAScript identifier
  */
-extern JS_PUBLIC_API bool JS_IsIdentifier(JSContext* cx, JS::HandleString str,
+extern "C" JS_PUBLIC_API bool JS_IsIdentifier(JSContext* cx, JS::HandleString str,
                                           bool* isIdentifier);
 
 /**
@@ -6733,4 +6733,96 @@ enum class CompletionKind { Normal, Return, Throw };
 
 } /* namespace js */
 
+/////////////// orel added
+extern "C" JS_PUBLIC_API JSObject*
+JS_NewArrayObject2(JSContext* cx, const JS::HandleValueArray& contents);
+
+extern "C" JS_PUBLIC_API JSObject*
+JS_NewDateObjectMsec(JSContext* cx, double msec);
+
+extern "C" JS_PUBLIC_API void*
+JS_GetContextOptions(JSContext* cx);
+
+extern "C" JS_PUBLIC_API void*
+JS_NewRootedValue(JSContext* cx, uint64_t initial);
+
+extern "C" JS_PUBLIC_API void
+JS_FreeRooteValue(void* val);
+
+extern "C" JS_PUBLIC_API void*
+JS_NewRootedObject(JSContext* cx, JSObject* initial);
+
+extern "C" JS_PUBLIC_API void
+JS_FreeRootedObject(void* obj);
+
+extern "C" JS_PUBLIC_API void*
+JS_NewRootedString(JSContext* cx, JSString* initial);
+
+extern "C" JS_PUBLIC_API void
+JS_FreeRootedString(void* str);
+
+extern "C" JS_PUBLIC_API void*
+JS_NewCompileOptions(JSContext* cx);
+
+extern "C" JS_PUBLIC_API void
+JS_FreeCompileOptions(void* co);
+
+extern "C" JS_PUBLIC_API void*
+JS_NewCompartmentOptions();
+
+extern "C" JS_PUBLIC_API void
+JS_FreeCompartmentOptions(void* opt);
+
+extern "C" JS_PUBLIC_API bool
+JS_EvaluateScript(JSContext* cx, const JS::CompileOptions& options,
+	const char* bytes, size_t length, JS::MutableHandleValue rval);
+
+extern "C" JS_PUBLIC_API bool
+JS_EvaluateUCScript(JSContext* cx, const JS::CompileOptions& options,
+	const char16_t* chars, size_t length, JS::MutableHandleValue rval);
+
+
+extern "C" JS_PUBLIC_API bool
+JS_InitModuleClasses(JSContext* cx, JS::Handle<JSObject*> obj);
+
+extern "C" JS_PUBLIC_API JSObject*
+JS_CompileModule(JSContext* cx, JS::Handle<JSObject*> obj, JS::CompileOptions& options,
+	const char16_t* chars, size_t length);
+
+extern "C" JS_PUBLIC_API void
+JS_SetModuleResolveHook(JSContext* cx, JS::Handle<JSFunction*> hook);
+
+extern "C" JS_PUBLIC_API JS::Value
+JS_ComputeThis(JSContext* cx, JS::Value* vp);
+
+extern "C" JS_PUBLIC_API bool
+JS_Initialize(void);
+
+extern "C" JS_PUBLIC_API uint64_t
+JS_GetReservedSlot1(JSObject* obj, uint32_t index);
+
+extern "C" JS_PUBLIC_API JS::AutoIdVector*
+JS_EnumerateToAutoIdVector(JSContext* cx, JS::HandleObject obj, size_t* length, jsid** data);
+
+extern "C" JS_PUBLIC_API void
+JS_DestroyAutoIdVector(JS::AutoIdVector* v);
+
+extern "C" JS_PUBLIC_API bool
+JS_DefinePropertyByIdNative(
+    JSContext* cx, JS::HandleObject obj, JS::HandleId id,
+    JSNative getter, JSNative setter, unsigned attrs);
+
+extern "C" JS_PUBLIC_API bool
+JS_DefinePropertyNative(
+    JSContext* cx, JS::HandleObject obj, const char* name,
+    JSNative getter, JSNative setter, unsigned attrs);
+
+extern "C" JS_PUBLIC_API bool
+JS_DefineUCPropertyNative(
+    JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
+    JSNative getter, JSNative setter, unsigned attrs);
+
+extern "C" JS_PUBLIC_API bool
+JS_IsRunning(JSContext* cx);
+
 #endif /* jsapi_h */
diff --git a/js/src/jsfriendapi.h b/js/src/jsfriendapi.h
index 4b8d18a4cb69..d95210bd8acc 100644
--- a/js/src/jsfriendapi.h
+++ b/js/src/jsfriendapi.h
@@ -1607,23 +1607,23 @@ static inline size_t scalarByteSize(Type atype) {
  * zeros.
  */
 
-extern JS_FRIEND_API JSObject* JS_NewInt8Array(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewInt8Array(JSContext* cx,
                                                uint32_t nelements);
-extern JS_FRIEND_API JSObject* JS_NewUint8Array(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewUint8Array(JSContext* cx,
                                                 uint32_t nelements);
-extern JS_FRIEND_API JSObject* JS_NewUint8ClampedArray(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewUint8ClampedArray(JSContext* cx,
                                                        uint32_t nelements);
-extern JS_FRIEND_API JSObject* JS_NewInt16Array(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewInt16Array(JSContext* cx,
                                                 uint32_t nelements);
-extern JS_FRIEND_API JSObject* JS_NewUint16Array(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewUint16Array(JSContext* cx,
                                                  uint32_t nelements);
-extern JS_FRIEND_API JSObject* JS_NewInt32Array(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewInt32Array(JSContext* cx,
                                                 uint32_t nelements);
-extern JS_FRIEND_API JSObject* JS_NewUint32Array(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewUint32Array(JSContext* cx,
                                                  uint32_t nelements);
-extern JS_FRIEND_API JSObject* JS_NewFloat32Array(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewFloat32Array(JSContext* cx,
                                                   uint32_t nelements);
-extern JS_FRIEND_API JSObject* JS_NewFloat64Array(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewFloat64Array(JSContext* cx,
                                                   uint32_t nelements);
 
 /*
@@ -1634,23 +1634,23 @@ extern JS_FRIEND_API JSObject* JS_NewFloat64Array(JSContext* cx,
  * conversion to the typed array element type.
  */
 
-extern JS_FRIEND_API JSObject* JS_NewInt8ArrayFromArray(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewInt8ArrayFromArray(JSContext* cx,
                                                         JS::HandleObject array);
-extern JS_FRIEND_API JSObject* JS_NewUint8ArrayFromArray(
+extern "C" JS_FRIEND_API JSObject* JS_NewUint8ArrayFromArray(
     JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API JSObject* JS_NewUint8ClampedArrayFromArray(
+extern "C" JS_FRIEND_API JSObject* JS_NewUint8ClampedArrayFromArray(
     JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API JSObject* JS_NewInt16ArrayFromArray(
+extern "C" JS_FRIEND_API JSObject* JS_NewInt16ArrayFromArray(
     JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API JSObject* JS_NewUint16ArrayFromArray(
+extern "C" JS_FRIEND_API JSObject* JS_NewUint16ArrayFromArray(
     JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API JSObject* JS_NewInt32ArrayFromArray(
+extern "C" JS_FRIEND_API JSObject* JS_NewInt32ArrayFromArray(
     JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API JSObject* JS_NewUint32ArrayFromArray(
+extern "C" JS_FRIEND_API JSObject* JS_NewUint32ArrayFromArray(
     JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API JSObject* JS_NewFloat32ArrayFromArray(
+extern "C" JS_FRIEND_API JSObject* JS_NewFloat32ArrayFromArray(
     JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API JSObject* JS_NewFloat64ArrayFromArray(
+extern "C" JS_FRIEND_API JSObject* JS_NewFloat64ArrayFromArray(
     JSContext* cx, JS::HandleObject array);
 
 /*
@@ -1660,31 +1660,31 @@ extern JS_FRIEND_API JSObject* JS_NewFloat64ArrayFromArray(
  * array is used as the default value.
  */
 
-extern JS_FRIEND_API JSObject* JS_NewInt8ArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewInt8ArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
-extern JS_FRIEND_API JSObject* JS_NewUint8ArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewUint8ArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
-extern JS_FRIEND_API JSObject* JS_NewUint8ClampedArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewUint8ClampedArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
-extern JS_FRIEND_API JSObject* JS_NewInt16ArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewInt16ArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
-extern JS_FRIEND_API JSObject* JS_NewUint16ArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewUint16ArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
-extern JS_FRIEND_API JSObject* JS_NewInt32ArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewInt32ArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
-extern JS_FRIEND_API JSObject* JS_NewUint32ArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewUint32ArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
-extern JS_FRIEND_API JSObject* JS_NewFloat32ArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewFloat32ArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
-extern JS_FRIEND_API JSObject* JS_NewFloat64ArrayWithBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_NewFloat64ArrayWithBuffer(
     JSContext* cx, JS::HandleObject arrayBuffer, uint32_t byteOffset,
     int32_t length);
 
@@ -1694,13 +1694,13 @@ extern JS_FRIEND_API JSObject* JS_NewFloat64ArrayWithBuffer(
  * JS::CompartmentCreationOptionsRef(cx).getSharedMemoryAndAtomicsEnabled() is
  * true.
  */
-extern JS_FRIEND_API JSObject* JS_NewSharedArrayBuffer(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewSharedArrayBuffer(JSContext* cx,
                                                        uint32_t nbytes);
 
 /**
  * Create a new ArrayBuffer with the given byte length.
  */
-extern JS_FRIEND_API JSObject* JS_NewArrayBuffer(JSContext* cx,
+extern "C" JS_FRIEND_API JSObject* JS_NewArrayBuffer(JSContext* cx,
                                                  uint32_t nbytes);
 
 /**
@@ -1709,7 +1709,7 @@ extern JS_FRIEND_API JSObject* JS_NewArrayBuffer(JSContext* cx,
  * this test or one of the JS_Is*Array tests succeeds, then it is safe to call
  * the various accessor JSAPI calls defined below.
  */
-extern JS_FRIEND_API bool JS_IsTypedArrayObject(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsTypedArrayObject(JSObject* obj);
 
 /**
  * Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may
@@ -1718,21 +1718,21 @@ extern JS_FRIEND_API bool JS_IsTypedArrayObject(JSObject* obj);
  * is safe to call the various ArrayBufferView accessor JSAPI calls defined
  * below.
  */
-extern JS_FRIEND_API bool JS_IsArrayBufferViewObject(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsArrayBufferViewObject(JSObject* obj);
 
 /*
  * Test for specific typed array types (ArrayBufferView subtypes)
  */
 
-extern JS_FRIEND_API bool JS_IsInt8Array(JSObject* obj);
-extern JS_FRIEND_API bool JS_IsUint8Array(JSObject* obj);
-extern JS_FRIEND_API bool JS_IsUint8ClampedArray(JSObject* obj);
-extern JS_FRIEND_API bool JS_IsInt16Array(JSObject* obj);
-extern JS_FRIEND_API bool JS_IsUint16Array(JSObject* obj);
-extern JS_FRIEND_API bool JS_IsInt32Array(JSObject* obj);
-extern JS_FRIEND_API bool JS_IsUint32Array(JSObject* obj);
-extern JS_FRIEND_API bool JS_IsFloat32Array(JSObject* obj);
-extern JS_FRIEND_API bool JS_IsFloat64Array(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsInt8Array(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsUint8Array(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsUint8ClampedArray(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsInt16Array(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsUint16Array(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsInt32Array(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsUint32Array(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsFloat32Array(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsFloat64Array(JSObject* obj);
 
 /**
  * Return the isShared flag of a typed array, which denotes whether
@@ -1742,7 +1742,7 @@ extern JS_FRIEND_API bool JS_IsFloat64Array(JSObject* obj);
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API bool JS_GetTypedArraySharedness(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_GetTypedArraySharedness(JSObject* obj);
 
 /*
  * Test for specific typed array types (ArrayBufferView subtypes) and return
@@ -1843,47 +1843,47 @@ JS_FRIEND_API uint8_t* JS_GetSharedArrayBufferData(JSObject* obj,
  * object cannot be viewed as the correct typed array, or the typed array
  * object on success, filling both outparameters.
  */
-extern JS_FRIEND_API JSObject* JS_GetObjectAsInt8Array(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsInt8Array(JSObject* obj,
                                                        uint32_t* length,
                                                        bool* isSharedMemory,
                                                        int8_t** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsUint8Array(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsUint8Array(JSObject* obj,
                                                         uint32_t* length,
                                                         bool* isSharedMemory,
                                                         uint8_t** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsUint8ClampedArray(
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsUint8ClampedArray(
     JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsInt16Array(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsInt16Array(JSObject* obj,
                                                         uint32_t* length,
                                                         bool* isSharedMemory,
                                                         int16_t** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsUint16Array(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsUint16Array(JSObject* obj,
                                                          uint32_t* length,
                                                          bool* isSharedMemory,
                                                          uint16_t** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsInt32Array(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsInt32Array(JSObject* obj,
                                                         uint32_t* length,
                                                         bool* isSharedMemory,
                                                         int32_t** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsUint32Array(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsUint32Array(JSObject* obj,
                                                          uint32_t* length,
                                                          bool* isSharedMemory,
                                                          uint32_t** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsFloat32Array(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsFloat32Array(JSObject* obj,
                                                           uint32_t* length,
                                                           bool* isSharedMemory,
                                                           float** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsFloat64Array(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsFloat64Array(JSObject* obj,
                                                           uint32_t* length,
                                                           bool* isSharedMemory,
                                                           double** data);
-extern JS_FRIEND_API JSObject* JS_GetObjectAsArrayBufferView(
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsArrayBufferView(
     JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
 
 /*
  * Unwrap an ArrayBuffer, return nullptr if it's a different type.
  */
-extern JS_FRIEND_API JSObject* JS_GetObjectAsArrayBuffer(JSObject* obj,
+extern "C" JS_FRIEND_API JSObject* JS_GetObjectAsArrayBuffer(JSObject* obj,
                                                          uint32_t* length,
                                                          uint8_t** data);
 
@@ -1895,9 +1895,9 @@ extern JS_FRIEND_API JSObject* JS_GetObjectAsArrayBuffer(JSObject* obj,
  * be known that it would pass such a test: it is an ArrayBufferView or a
  * wrapper of an ArrayBufferView, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API js::Scalar::Type JS_GetArrayBufferViewType(JSObject* obj);
+extern "C" JS_FRIEND_API js::Scalar::Type JS_GetArrayBufferViewType(JSObject* obj);
 
-extern JS_FRIEND_API js::Scalar::Type JS_GetSharedArrayBufferViewType(
+extern "C" JS_FRIEND_API js::Scalar::Type JS_GetSharedArrayBufferViewType(
     JSObject* obj);
 
 /*
@@ -1906,9 +1906,9 @@ extern JS_FRIEND_API js::Scalar::Type JS_GetSharedArrayBufferViewType(
  * unwrapping. If this test succeeds, then it is safe to call the various
  * accessor JSAPI calls defined below.
  */
-extern JS_FRIEND_API bool JS_IsArrayBufferObject(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsArrayBufferObject(JSObject* obj);
 
-extern JS_FRIEND_API bool JS_IsSharedArrayBufferObject(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsSharedArrayBufferObject(JSObject* obj);
 
 /**
  * Return the available byte length of an array buffer.
@@ -1917,9 +1917,9 @@ extern JS_FRIEND_API bool JS_IsSharedArrayBufferObject(JSObject* obj);
  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
  * ArrayBuffer, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API uint32_t JS_GetArrayBufferByteLength(JSObject* obj);
+extern "C" JS_FRIEND_API uint32_t JS_GetArrayBufferByteLength(JSObject* obj);
 
-extern JS_FRIEND_API uint32_t JS_GetSharedArrayBufferByteLength(JSObject* obj);
+extern "C" JS_FRIEND_API uint32_t JS_GetSharedArrayBufferByteLength(JSObject* obj);
 
 /**
  * Return true if the arrayBuffer contains any data. This will return false for
@@ -1929,7 +1929,7 @@ extern JS_FRIEND_API uint32_t JS_GetSharedArrayBufferByteLength(JSObject* obj);
  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
  * ArrayBuffer, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API bool JS_ArrayBufferHasData(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_ArrayBufferHasData(JSObject* obj);
 
 /**
  * Return a pointer to the start of the data referenced by a typed array. The
@@ -1945,7 +1945,7 @@ extern JS_FRIEND_API bool JS_ArrayBufferHasData(JSObject* obj);
  * |*isSharedMemory| will be set to false, the argument is present to simplify
  * its use from code that also interacts with SharedArrayBuffer.
  */
-extern JS_FRIEND_API uint8_t* JS_GetArrayBufferData(JSObject* obj,
+extern "C" JS_FRIEND_API uint8_t* JS_GetArrayBufferData(JSObject* obj,
                                                     bool* isSharedMemory,
                                                     const JS::AutoRequireNoGC&);
 
@@ -1954,7 +1954,7 @@ extern JS_FRIEND_API uint8_t* JS_GetArrayBufferData(JSObject* obj,
  * may return false if a security wrapper is encountered that denies the
  * unwrapping.
  */
-extern JS_FRIEND_API bool JS_IsMappedArrayBufferObject(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsMappedArrayBufferObject(JSObject* obj);
 
 /**
  * Return the number of elements in a typed array.
@@ -1963,7 +1963,7 @@ extern JS_FRIEND_API bool JS_IsMappedArrayBufferObject(JSObject* obj);
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API uint32_t JS_GetTypedArrayLength(JSObject* obj);
+extern "C" JS_FRIEND_API uint32_t JS_GetTypedArrayLength(JSObject* obj);
 
 /**
  * Return the byte offset from the start of an array buffer to the start of a
@@ -1973,7 +1973,7 @@ extern JS_FRIEND_API uint32_t JS_GetTypedArrayLength(JSObject* obj);
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API uint32_t JS_GetTypedArrayByteOffset(JSObject* obj);
+extern "C" JS_FRIEND_API uint32_t JS_GetTypedArrayByteOffset(JSObject* obj);
 
 /**
  * Return the byte length of a typed array.
@@ -1982,19 +1982,19 @@ extern JS_FRIEND_API uint32_t JS_GetTypedArrayByteOffset(JSObject* obj);
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API uint32_t JS_GetTypedArrayByteLength(JSObject* obj);
+extern "C" JS_FRIEND_API uint32_t JS_GetTypedArrayByteLength(JSObject* obj);
 
 /**
  * Check whether obj supports JS_ArrayBufferView* APIs. Note that this may
  * return false if a security wrapper is encountered that denies the
  * unwrapping.
  */
-extern JS_FRIEND_API bool JS_IsArrayBufferViewObject(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsArrayBufferViewObject(JSObject* obj);
 
 /**
  * More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
  */
-extern JS_FRIEND_API uint32_t JS_GetArrayBufferViewByteLength(JSObject* obj);
+extern "C" JS_FRIEND_API uint32_t JS_GetArrayBufferViewByteLength(JSObject* obj);
 
 /**
  * More generic name for JS_GetTypedArrayByteOffset to cover DataViews as well
@@ -2016,28 +2016,28 @@ extern JS_FRIEND_API uint32_t JS_GetArrayBufferViewByteOffset(JSObject* obj);
  * SharedArrayBuffer, otherwise to false.
  */
 
-extern JS_FRIEND_API int8_t* JS_GetInt8ArrayData(JSObject* obj,
+extern "C" JS_FRIEND_API int8_t* JS_GetInt8ArrayData(JSObject* obj,
                                                  bool* isSharedMemory,
                                                  const JS::AutoRequireNoGC&);
-extern JS_FRIEND_API uint8_t* JS_GetUint8ArrayData(JSObject* obj,
+extern "C" JS_FRIEND_API uint8_t* JS_GetUint8ArrayData(JSObject* obj,
                                                    bool* isSharedMemory,
                                                    const JS::AutoRequireNoGC&);
-extern JS_FRIEND_API uint8_t* JS_GetUint8ClampedArrayData(
+extern "C" JS_FRIEND_API uint8_t* JS_GetUint8ClampedArrayData(
     JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
-extern JS_FRIEND_API int16_t* JS_GetInt16ArrayData(JSObject* obj,
+extern "C" JS_FRIEND_API int16_t* JS_GetInt16ArrayData(JSObject* obj,
                                                    bool* isSharedMemory,
                                                    const JS::AutoRequireNoGC&);
-extern JS_FRIEND_API uint16_t* JS_GetUint16ArrayData(
+extern "C" JS_FRIEND_API uint16_t* JS_GetUint16ArrayData(
     JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
-extern JS_FRIEND_API int32_t* JS_GetInt32ArrayData(JSObject* obj,
+extern "C" JS_FRIEND_API int32_t* JS_GetInt32ArrayData(JSObject* obj,
                                                    bool* isSharedMemory,
                                                    const JS::AutoRequireNoGC&);
-extern JS_FRIEND_API uint32_t* JS_GetUint32ArrayData(
+extern "C" JS_FRIEND_API uint32_t* JS_GetUint32ArrayData(
     JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
-extern JS_FRIEND_API float* JS_GetFloat32ArrayData(JSObject* obj,
+extern "C" JS_FRIEND_API float* JS_GetFloat32ArrayData(JSObject* obj,
                                                    bool* isSharedMemory,
                                                    const JS::AutoRequireNoGC&);
-extern JS_FRIEND_API double* JS_GetFloat64ArrayData(JSObject* obj,
+extern "C" JS_FRIEND_API double* JS_GetFloat64ArrayData(JSObject* obj,
                                                     bool* isSharedMemory,
                                                     const JS::AutoRequireNoGC&);
 
@@ -2045,7 +2045,7 @@ extern JS_FRIEND_API double* JS_GetFloat64ArrayData(JSObject* obj,
  * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
  * versions when possible.
  */
-extern JS_FRIEND_API void* JS_GetArrayBufferViewData(
+extern "C" JS_FRIEND_API void* JS_GetArrayBufferViewData(
     JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 
 /**
@@ -2053,7 +2053,7 @@ extern JS_FRIEND_API void* JS_GetArrayBufferViewData(
  * This may return a detached buffer.  |obj| must be an object that would
  * return true for JS_IsArrayBufferViewObject().
  */
-extern JS_FRIEND_API JSObject* JS_GetArrayBufferViewBuffer(
+extern "C" JS_FRIEND_API JSObject* JS_GetArrayBufferViewBuffer(
     JSContext* cx, JS::HandleObject obj, bool* isSharedMemory);
 
 /**
@@ -2062,7 +2062,7 @@ extern JS_FRIEND_API JSObject* JS_GetArrayBufferViewBuffer(
  *
  * The |changeData| argument is obsolete and ignored.
  */
-extern JS_FRIEND_API bool JS_DetachArrayBuffer(JSContext* cx,
+extern "C" JS_FRIEND_API bool JS_DetachArrayBuffer(JSContext* cx,
                                                JS::HandleObject obj);
 
 /**
@@ -2070,7 +2070,7 @@ extern JS_FRIEND_API bool JS_DetachArrayBuffer(JSContext* cx,
  * return false if a security wrapper is encountered that denies the
  * unwrapping.
  */
-extern JS_FRIEND_API bool JS_IsDetachedArrayBufferObject(JSObject* obj);
+extern "C" JS_FRIEND_API bool JS_IsDetachedArrayBufferObject(JSObject* obj);
 
 /**
  * Check whether obj supports JS_GetDataView* APIs.
