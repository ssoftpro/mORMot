/**
 * SyNode file-system routines. We try to implement here the same interface as in <a href="http://nodejs.org/api/fs.html">NodeJS fs</a>
 *
 *      var fs = require('fs');
 *      var content = fs.readFileSync('c:\\a.txt', 'utf-8);
 *
 * @module fs
 * @memberOf module:buildin
 */
'use strict'

const constants = process.binding('constants').fs
const { S_IFIFO, S_IFLNK, S_IFMT, S_IFREG, S_IFSOCK } = constants
const util = require('util')
const pathModule = require('path')
const { isUint8Array } = require('internal/util/types')

const binding = process.binding('fs')
const fs = exports
const internalFS = require('internal/fs')
const { getPathFromURL } = require('internal/url')
const {
  assertEncoding,
  stringToFlags
} = internalFS

Object.defineProperty(exports, 'constants', {
  configurable: false,
  enumerable: true,
  value: constants
})

const kMinPoolSpace = 128
const { kMaxLength } = require('buffer')

const isWindows = process.platform === 'win32'

function getOptions(options, defaultOptions) {
  if (options === null || options === undefined ||
      typeof options === 'function') {
    return defaultOptions;
  }

  if (typeof options === 'string') {
    defaultOptions = util._extend({}, defaultOptions);
    defaultOptions.encoding = options;
    options = defaultOptions;
  } else if (typeof options !== 'object') {
    throw new TypeError('"options" must be a string or an object, got ' +
                        typeof options + ' instead.');
  }

  if (options.encoding !== 'buffer' && options.encoding !== 'bin')
    assertEncoding(options.encoding);
  return options;
}

function copyObject(source) {
  var target = {};
  for (var key in source)
    target[key] = source[key];
  return target;
}

function rethrow() {
  return function(err) {
    if (err) {
      throw err;
    }
  };
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

// Ensure that callbacks run in the global context. Only use this function
// for callbacks that are passed to the binding layer, callbacks that are
// invoked from JS already run in the proper scope.
function makeCallback(cb) {
  if (cb === undefined) {
    return rethrow();
  }

  if (typeof cb !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  return function() {
    return cb.apply(null, arguments);
  };
}

// Special case of `makeCallback()` that is specific to async `*stat()` calls as
// an optimization, since the data passed back to the callback needs to be
// transformed anyway.
function makeStatsCallback(cb) {
  if (cb === undefined) {
    return rethrow();
  }

  if (typeof cb !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  return function(err, vals) {
    if (err) return cb(err);
    cb(err, statsFromValues(vals));
  };
}

function makeOneArgFuncAsync(oneArgSyncFunc){
  return function(arg, cb){
    var _res;
    var callback = maybeCallback(cb);
    try {
      _res = oneArgSyncFunc(arg);
      callback(null, _res);
    } catch(e){
      callback(e);
    }
  }
}

function nullCheck(path, callback) {
  if (('' + path).indexOf('\u0000') !== -1) {
    var er = new Error('Path must be a string without null bytes');
    er.code = 'ENOENT';
    if (typeof callback !== 'function')
      throw er;
    callback(er);
    return false;
  }
  return true;
}

function isFd(path) {
  return (path >>> 0) === path;
}

// Constructor for file stats.
function Stats(
  dev,
  mode,
  nlink,
  uid,
  gid,
  rdev,
  blksize,
  ino,
  size,
  blocks,
  atime,
  mtime,
  ctime,
  birthtime
) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
  this.atime = atime;
  this.mtime = mtime;
  this.ctime = ctime;
  this.birthtime = birthtime;
}
fs.Stats = Stats;

Stats.prototype._checkModeProperty = function(property) {
  return ((this.mode & S_IFMT) === property);
};

Stats.prototype.isDirectory = function() {
  return this._checkModeProperty(constants.S_IFDIR);
};

Stats.prototype.isFile = function() {
  return this._checkModeProperty(S_IFREG);
};

Stats.prototype.isBlockDevice = function() {
  return this._checkModeProperty(constants.S_IFBLK);
};

Stats.prototype.isCharacterDevice = function() {
  return this._checkModeProperty(constants.S_IFCHR);
};

Stats.prototype.isSymbolicLink = function() {
  return this._checkModeProperty(S_IFLNK);
};

Stats.prototype.isFIFO = function() {
  return this._checkModeProperty(S_IFIFO);
};

Stats.prototype.isSocket = function() {
  return this._checkModeProperty(S_IFSOCK);
};
function statsFromValues(statValues) {
  return new Stats(statValues.dev, statValues.mode, statValues.nlink, statValues.uid,
                   statValues.gid, statValues.rdev,
                   statValues.blksize < 0 ? undefined : statValues.blksize, statValues.ino,
                   statValues.size, statValues.blocks < 0 ? undefined : statValues.blocks,
                   statValues.atime, statValues.mtime, statValues.ctime,
                   statValues.birthtime);
}

// Don't allow mode to accidentally be overwritten.
Object.defineProperties(fs, {
  F_OK: { enumerable: true, value: constants.F_OK || 0 },
  R_OK: { enumerable: true, value: constants.R_OK || 0 },
  W_OK: { enumerable: true, value: constants.W_OK || 0 },
  X_OK: { enumerable: true, value: constants.X_OK || 0 },
});

function handleError(val, callback) {
  if (val instanceof Error) {
    if (typeof callback === 'function') {
      callback(val);
      return true;
    } else throw val;
  }
  return false;
}

fs.access = function(path, mode, callback) {
  if (typeof mode === 'function') {
    callback = mode;
    mode = fs.F_OK;
  } else if (typeof callback !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  if (handleError((path = getPathFromURL(path)), callback))
    return;

  if (!nullCheck(path, callback))
    return;

  mode = mode | 0;
  
  let oncomplete = makeCallback(callback);
  let err = null
  try {
    binding.access(pathModule._makeLong(path), mode)
  } catch (e) {
    err = e
  }
  oncomplete(err);
};

fs.accessSync = function(path, mode) {
  handleError((path = getPathFromURL(path)));
  nullCheck(path);

  if (mode === undefined)
    mode = fs.F_OK;
  else
    mode = mode | 0;

  binding.access(pathModule._makeLong(path), mode);
};

fs.exists = function(path, callback) {
  if (handleError((path = getPathFromURL(path)), cb))
    return;
  if (!nullCheck(path, cb)) return;
  var req = new FSReqWrap();
  req.oncomplete = cb;
  binding.stat(pathModule._makeLong(path), req);
  function cb(err) {
    if (callback) callback(err ? false : true);
  }
};

/**
 * Check `path` exists (can be file, folder or symlync)
 * @param path
 * @return {Boolean}
 */
fs.existsSync = function (path){
  try {
    handleError((path = getPathFromURL(path)));
    nullCheck(path);
    return !!binding.stat(pathModule._makeLong(path));
  } catch (e) {
    return false;
  }
};

fs.readFile = function (path, options, callback_){
  var stat = fileStat(path);
  var callback = maybeCallback(arguments[arguments.length - 1]);
  options = getOptions(options, { flag: 'r' });
  if (!stat) {
    callback(new Error('no such file or directory, open \'' + path + '\''));
  } else {
    callback(null, readFileSync(path, options))
  }
};

function tryStatSync(fd, isUserFd) {
  var threw = true;
  var result;
  try {
    result = binding.fileStat(fd);
    threw = false;
  } finally {
    if (threw && !isUserFd) fs.closeSync(fd);
  }
  return result;
}

function tryCreateBuffer(size, fd, isUserFd) {
  var threw = true;
  var buffer;
  try {
    buffer = Buffer.allocUnsafe(size);
    threw = false;
  } finally {
    if (threw && !isUserFd) fs.closeSync(fd);
  }
  return buffer;
}

function tryReadSync(fd, isUserFd, buffer, pos, len) {
  var threw = true;
  var bytesRead;
  try {
    bytesRead = fs.readSync(fd, buffer, pos, len);
    threw = false;
  } finally {
    if (threw && !isUserFd) fs.closeSync(fd);
  }
  return bytesRead;
}

/**
 * Reads the entire contents of a file. If options.encoding == 'bin', then the ArrayBuffer is returned.
 * If no options is specified at all - result is String as in {@link fs.loadFile}
 * @param {String} path  Absolute path to file
 * @param {Object} [options]
 * @param {String|Null} [options.encoding] Default to null. Possible values: 'bin'|'ascii'|'utf-8'
 * @returns {String|ArrayBuffer}
 */
fs.readFileSync = function(path, options) {
  options = getOptions(options, { flag: 'r' });
  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, options.flag || 'r', 0o666);

  let statValues = tryStatSync(fd, isUserFd);
  var size;
  if ((statValues.mode & S_IFMT) === S_IFREG)
    size = statValues.size;
  else
    size = 0;
  var pos = 0;
  var buffer; // single buffer with file data
  var buffers; // list for when size is unknown

  if (size === 0) {
    buffers = [];
  } else {
    buffer = tryCreateBuffer(size, fd, isUserFd);
  }

  var bytesRead;

  if (size !== 0) {
    do {
      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);
      pos += bytesRead;
    } while (bytesRead !== 0 && pos < size);
  } else {
    do {
      // the kernel lies about many files.
      // Go ahead and try to read some bytes.
      buffer = Buffer.allocUnsafe(8192);
      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);
      if (bytesRead !== 0) {
        buffers.push(buffer.slice(0, bytesRead));
      }
      pos += bytesRead;
    } while (bytesRead !== 0);
  }

  if (!isUserFd)
    fs.closeSync(fd);

  if (size === 0) {
    // data was collected into the buffers list.
    buffer = Buffer.concat(buffers, pos);
  } else if (pos < size) {
    buffer = buffer.slice(0, pos);
  }

  if (options.encoding && options.encoding !== 'bin')
    buffer = buffer.toString(options.encoding);
  return buffer;
};

fs.close = function(fd, callback) {
  let oncomplete = makeCallback(callback);
  let err = null;
  try {
    binding.close(fd);
  } catch (e) {
    err = e
  }
  oncomplete(err);
};

fs.closeSync = function(fd) {
  return binding.close(fd);
};

function modeNum(m, def) {
  if (typeof m === 'number')
    return m;
  if (typeof m === 'string')
    return parseInt(m, 8);
  if (def)
    return modeNum(def);
  return undefined;
}

fs.open = function(path, flags, mode, callback_) {
  var callback = makeCallback(arguments[arguments.length - 1]);
  mode = modeNum(mode, 0o666);

  if (handleError((path = getPathFromURL(path)), callback))
    return;
  if (!nullCheck(path, callback)) return;

  let oncomplete = callback;
  let err = null;

  try {
    binding.open(pathModule._makeLong(path), stringToFlags(flags), mode)
  } catch (e) {
    err = e
  }
  oncomplete(err)
};

fs.openSync = function(path, flags, mode) {
  mode = modeNum(mode, 0o666);
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);
};

fs.read = function(fd, buffer, offset, length, position, callback) {
  if (length === 0) {
    return process.nextTick(function() {
      callback && callback(null, 0, buffer);
    });
  }

  function wrapper(err, bytesRead) {
    // Retain a reference to buffer so that it can't be GC'ed too soon.
    callback && callback(err, bytesRead || 0, buffer);
  }

  let oncomplete = wrapper;
  let err = null;
  try {
    binding.read(fd, buffer, offset, length, position);
  } catch (e) {
    err = e
  }
  oncomplete(err)
};

fs.readSync = function(fd, buffer, offset, length, position) {
  if (length === 0) {
    return 0;
  }

  return binding.read(fd, buffer, offset, length, position);
};

// usage:
//  fs.write(fd, buffer[, offset[, length[, position]]], callback);
// OR
//  fs.write(fd, string[, position[, encoding]], callback);
fs.write = function(fd, buffer, offset, length, position, callback) {
  function wrapper(err, written) {
    // Retain a reference to buffer so that it can't be GC'ed too soon.
    callback(err, written || 0, buffer);
  }

  let err = null
  let oncomplete = wrapper;
  let written = 0;

  if (isUint8Array(buffer)) {
    callback = maybeCallback(callback || position || length || offset);
    if (typeof offset !== 'number') {
      offset = 0;
    }
    if (typeof length !== 'number') {
      length = buffer.length - offset;
    }
    if (typeof position !== 'number') {
      position = null;
    }
    try {
      written = binding.writeBuffer(fd, buffer, offset, length, position);
    } catch (e) {
      err = e
    }
    oncomplete(err, written);
    return;
  }

  if (typeof buffer !== 'string')
    buffer += '';
  if (typeof position !== 'function') {
    if (typeof offset === 'function') {
      position = offset;
      offset = null;
    } else {
      position = length;
    }
    length = 'utf8';
  }
  callback = maybeCallback(position);
  try {
    written = binding.writeString(fd, buffer, offset, length);
  } catch (e) {
    err = e
  }
  oncomplete(err, written);
  return;
};

// usage:
//  fs.writeSync(fd, buffer[, offset[, length[, position]]]);
// OR
//  fs.writeSync(fd, string[, position[, encoding]]);
fs.writeSync = function(fd, buffer, offset, length, position) {
  if (isUint8Array(buffer)) {
    if (position === undefined)
      position = null;
    if (typeof offset !== 'number')
      offset = 0;
    if (typeof length !== 'number')
      length = buffer.length - offset;
    return binding.writeBuffer(fd, buffer, offset, length/*, position*/);
  }
  if (typeof buffer !== 'string')
    buffer += '';
  // fs.writeSync(fd, string[, position[, encoding]])
  if (offset === undefined || offset === null)
    offset = 0; // actually this is position
  if (length === undefined || length === null)
    length = 'utf8'; // actually this is encoding
  return binding.writeString(fd, buffer, offset, length);
};

fs.rename = function(oldPath, newPath, callback) {
  callback = makeCallback(callback);
  if (handleError((oldPath = getPathFromURL(oldPath)), callback))
    return;

  if (handleError((newPath = getPathFromURL(newPath)), callback))
    return;

  if (!nullCheck(oldPath, callback)) return;
  if (!nullCheck(newPath, callback)) return;
  
  let oncomplete = callback;
  let err = null;
  try {
    binding.rename(pathModule._makeLong(oldPath), pathModule._makeLong(newPath));
  } catch (e) {
    err = e
  }
  oncomplete(err);
};

fs.renameSync = function(oldPath, newPath) {
  handleError((oldPath = getPathFromURL(oldPath)));
  handleError((newPath = getPathFromURL(newPath)));
  nullCheck(oldPath);
  nullCheck(newPath);
  return binding.rename(pathModule._makeLong(oldPath),
                        pathModule._makeLong(newPath));
};

fs.truncate = function(path, len, callback) {
  if (typeof path === 'number') {
    return fs.ftruncate(path, len, callback);
  }
  if (typeof len === 'function') {
    callback = len;
    len = 0;
  } else if (len === undefined) {
    len = 0;
  }

  callback = maybeCallback(callback);
  fs.open(path, 'r+', function(er, fd) {
    if (er) return callback(er);
    let err = null;
    let oncomplete = function oncomplete(er) {
      fs.close(fd, function(er2) {
        callback(er || er2);
      });
    };
    try {
      binding.ftruncate(fd, len);
    } catch (e) {
      err = e
    }
    oncomplete(err);
  });
};

fs.truncateSync = function(path, len) {
  if (typeof path === 'number') {
    // legacy
    return fs.ftruncateSync(path, len);
  }
  if (len === undefined) {
    len = 0;
  }
  // allow error to be thrown, but still close fd.
  var fd = fs.openSync(path, 'r+');
  var ret;

  try {
    ret = fs.ftruncateSync(fd, len);
  } finally {
    fs.closeSync(fd);
  }
  return ret;
};

fs.ftruncate = function(fd, len, callback) {
  if (typeof len === 'function') {
    callback = len;
    len = 0;
  } else if (len === undefined) {
    len = 0;
  }
  let err = null;
  let oncomplete = makeCallback(callback);
  try {
    binding.ftruncate(fd, len);
  } catch (e) {
    err = e
  }
  oncomplete(err);
};

fs.ftruncateSync = function(fd, len) {
  if (len === undefined) {
    len = 0;
  }
  return binding.ftruncate(fd, len);
};

fs.rmdir = function(path, callback) {
  callback = maybeCallback(callback);
  if (handleError((path = getPathFromURL(path)), callback))
    return;
  if (!nullCheck(path, callback)) return;
  let err = null;
  let oncomplete = callback;
  let res
  try {
    res = binding.rmdir(pathModule._makeLong(path));
  } catch (e) {
    err = e
  }
  oncomplete(err, res)
};

/**
 * Delete non-empty directory. See {@link removeDir} for details
 * @param {String} path path to remove
 */
fs.rmdirSync = function (path) {
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
  return binding.rmdir(pathModule._makeLong(path));
};

fs.mkdir = function(path, mode, callback) {
  if (typeof mode === 'function') callback = mode;
  callback = makeCallback(callback);
  if (handleError((path = getPathFromURL(path)), callback))
    return;
  if (!nullCheck(path, callback)) return;
  let err = null
  let oncomplete = callback;
  try {
    binding.mkdir(pathModule._makeLong(path), modeNum(mode, 0o777));
  } catch (e) {
    err = e
  }
  oncomplete(err);
};

//noinspection JSUnusedLocalSymbols
/**
 * Create all missing folders in the given path. Only absolute path supported. Throw error in case of fail
 * @param {String} path path for creation.
 * @param {Number} [mode] Ignored under Windows
 */
fs.mkdirSync = function(path, mode) {
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
  return binding.mkdir(pathModule._makeLong(path),
                       modeNum(mode, 0o777));
};


/** Read file names from directory (include folder names).
 * Return array of file names. In case directory not exists - throw error
 * @param {String} path
 * @return {Array.<String>}
 */
fs.readdirSync = function(path, options) {
  options = getOptions(options, {});
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
  return binding.readdir(pathModule._makeLong(path), options.encoding);
};

fs.fstat = function(fd, callback) {
  let err = null
  let oncomplete = makeStatsCallback(callback);
  let res;
  try {
    res = binding.fileStat(fd, req);
  } catch (e) {
    err = e;
  }
  oncomplete(err, res);
};

fs.lstat = function(path, callback) {
  callback = makeStatsCallback(callback);
  if (handleError((path = getPathFromURL(path)), callback))
    return;
  if (!nullCheck(path, callback)) return;
  let err = null;
  let oncomplete = callback;
  let res;
  try {
    res = binding.fileStat(pathModule._makeLong(path), req);
  } catch (e) {
    err = e
  }
  oncomplete(err, res);
};

fs.stat = function(path, callback) {
  callback = makeStatsCallback(callback);
  if (handleError((path = getPathFromURL(path)), callback))
    return;
  if (!nullCheck(path, callback)) return;
  let err = null
  let oncomplete = callback;
  let res;
  try {
    res = binding.fileStat(pathModule._makeLong(path));
  } catch (e) {
    err = e
  }
  oncomplete(err, res);
};


fs.fstatSync = function(fd) {
  let vals = binding.fstat(fd);
  return statsFromValues(vals);
};

fs.lstatSync = function(path) {
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
  let vals = binding.fileStat(pathModule._makeLong(path), true);
  return statsFromValues(vals);
};

/**
 * Get file statistics. Will throw in case file or folder does not exists.
 * @param path
 * @returns {Boolean|{atime: Date, mtime: Date, ctime: Date, size: number, _fileName: string, isDirectory: function}}
 */
fs.statSync = function(path) {
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
  let vals = binding.fileStat(pathModule._makeLong(path));
  return statsFromValues(vals);
};

fs.unlink = function(path, callback) {
  callback = makeCallback(callback);
  if (handleError((path = getPathFromURL(path)), callback))
    return;
  if (!nullCheck(path, callback)) return;
  let err = null;
  let oncomplete = callback;
  let res;
  try {
    res = binding.unlink(pathModule._makeLong(path));
  } catch (e) {
    err = e
  }
  oncomplete(err, res);
};

fs.unlinkSync = function(path) {
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
  return binding.unlink(pathModule._makeLong(path));
};

/**
 * Write to file
 * Actually implements {@link UBWriter#write}
 * @param {String} path  Full absolute file path
 * @param {ArrayBuffer|Object|String} data Data to write. If Object - it stringify before write
 * @param {Object} [options]
 * @param {String} [options.encoding] Encode data to `encoding` before write. Default to `utf-8` in case data is String or `bin` in case data is ArrayBuffer.
 *                              One of "utf-8"|"ucs2"|"bin"|"base64".
 */
fs.writeFileSync = function(path, data, options) {
  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });
  const flag = options.flag || 'w';

  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);

  if (!isUint8Array(data)) {
    if (typeof data !== 'string') {
      try {
        binding.writeFile(fd, data); // ub compatibility workaround
      } finally {
        if (!isUserFd) fs.closeSync(fd);
      }
      return
    }
    data = Buffer.from('' + data, options.encoding || 'utf8');
  }
  var offset = 0;
  var length = data.length;
  var position = /a/.test(flag) ? null : 0;
  try {
    while (length > 0) {
      var written = fs.writeSync(fd, data, offset, length, position);
      offset += written;
      length -= written;
      if (position !== null) {
        position += written;
      }
    }
  } finally {
    if (!isUserFd) fs.closeSync(fd);
  }
};

fs.appendFile = function(path, data, options, callback) {
  callback = maybeCallback(callback || options);
  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });

  // Don't make changes directly on options object
  options = copyObject(options);

  // force append behavior when using a supplied file descriptor
  if (!options.flag || isFd(path))
    options.flag = 'a';

  fs.writeFile(path, data, options, callback);
};

/**
 * Append data to a file, creating the file if it not yet exists
 * Actually implement {UBWriter#write}
 * @param {String} path  Full absolute file path
 * @param {ArrayBuffer|Object|String} data Data to write. `Object` are stringified before write
 * @param {Object} [options]
 * @param {String} [options.encoding] Encode data to `encoding` before write.
 *  Default to `utf-8` in case data is String or `bin` in case data is ArrayBuffer.
 *  Possible values: "utf-8"|"ucs2"|"bin"|"base64".
 */
fs.appendFileSync = function(path, data, options) {
  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });

  // Don't make changes directly on options object
  options = copyObject(options);

  // force append behavior when using a supplied file descriptor
  if (!options.flag || isFd(path))
    options.flag = 'a';

  fs.writeFileSync(path, data, options);
};


/**
 * Move (rename) file.
 * @param {String} oldPath
 * @param {String} newPath
 */
/**
 * Fake class for nodeJS compatibility
 */
fs.ReadStream = ReadStream;
function ReadStream(){}

function modeNum(m, def) {
  if (typeof m === 'number')
    return m;
  if (typeof m === 'string')
    return parseInt(m, 8);
  if (def)
    return modeNum(def);
  return undefined;
}

const emptyObj = Object.create(null);
/**
 * Synchronous realpath(3). Returns the resolved path (resolve symlinks, junctions on Windows, /../)
 */
fs.realpathSync = function realpathSync(p, options) {
  if (!options)
    options = emptyObj;
  else
    options = getOptions(options, emptyObj);
  if (typeof p !== 'string') {
    handleError((p = getPathFromURL(p)));
    if (typeof p !== 'string')
      p += '';
  }
  nullCheck(p);
  p = pathModule.resolve(p);

  const cache = options[internalFS.realpathCacheKey];
  const maybeCachedResult = cache && cache.get(p);
  if (maybeCachedResult) {
    return maybeCachedResult;
  }
  let res = binding.realpath(p);
  if (cache) cache.set(p, res);
  return res;
};
