/**
 * SyNode file-system routines. We try to implement here the same interface as in <a href="http://nodejs.org/api/fs.html">NodeJS fs</a>
 *
 *      var fs = require('fs');
 *      var content = fs.readFileSync('c:\\a.txt', 'utf-8);
 *
 * @module fs
 */

const constants = process.binding('constants').fs
const { S_IFIFO, S_IFLNK, S_IFMT, S_IFREG, S_IFSOCK } = constants
const util = require('util')
const pathModule = require('path')
const { isUint8Array } = require('internal/util/types')
const {
  fileStat,
  directoryExists,
  fileExists,
  readDir,
  realpath,
  rename,
  deleteFile,
  forceDirectories,
  removeDir,
  openFile,
  closeFile,
  readFile,
  writeFile, // for compatibility
  writeFileBuffer,
  writeFileString,
} = process.binding('fs')
const fs = exports
const internalFS = require('internal/fs')
const { getPathFromURL } = require('internal/url')
const {
  assertEncoding,
  stringToFlags
} = internalFS;

Object.defineProperty(exports, 'constants', {
  configurable: false,
  enumerable: true,
  value: constants
})

const kMinPoolSpace = 128;
const { kMaxLength } = require('buffer')

const isWindows = process.platform === 'win32'

function getOptions(options, defaultOptions) {
  if (options === null || options === undefined ||
      typeof options === 'function') {
    return defaultOptions;
  }

  if (typeof options === 'string') {
    defaultOptions = util._extend({}, defaultOptions);
    defaultOptions.encoding = options;
    options = defaultOptions;
  } else if (typeof options !== 'object') {
    throw new TypeError('"options" must be a string or an object, got ' +
                        typeof options + ' instead.');
  }

  if (options.encoding !== 'buffer' && options.encoding !== 'bin')
    assertEncoding(options.encoding);
  return options;
}

function copyObject(source) {
  var target = {};
  for (var key in source)
    target[key] = source[key];
  return target;
}

function rethrow() {
  return function(err) {
    if (err) {
      throw err;
    }
  };
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

function makeOneArgFuncAsync(oneArgSyncFunc){
  return function(arg, cb){
    var _res;
    var callback = maybeCallback(cb);
    try {
      _res = oneArgSyncFunc(arg);
      callback(null, _res);
    } catch(e){
      callback(e);
    }
  }
}

function nullCheck(path, callback) {
  if (('' + path).indexOf('\u0000') !== -1) {
    var er = new Error('Path must be a string without null bytes');
    er.code = 'ENOENT';
    // SyNode if (typeof callback !== 'function')
      throw er;
    // SyNode process.nextTick(callback, er);
    // SyNode return false;
  }
  return true;
}

function isFd(path) {
  return (path >>> 0) === path;
}

/**
 * Check specified path is file (or symlynk to file)
 * @param path
 * @return {Boolean}
 */
exports.isFile  = function isFile(path){
    return fileExists(path);
};

/**
 * Check specified path is folder (or symlynk to folder)
 * @param path
 * @return {Boolean}
 */
exports.isDir = function isDir(path){
    return directoryExists(path);
};

// Don't allow mode to accidentally be overwritten.
Object.defineProperties(fs, {
  F_OK: { enumerable: true, value: constants.F_OK || 0 },
  R_OK: { enumerable: true, value: constants.R_OK || 0 },
  W_OK: { enumerable: true, value: constants.W_OK || 0 },
  X_OK: { enumerable: true, value: constants.X_OK || 0 },
});

function handleError(val, callback) {
  if (val instanceof Error) {
    /*if (typeof callback === 'function') {
      process.nextTick(callback, val);
      return true;
    } else*/ throw val;
  }
  return false;
}

fs.accessSync = function(path, mode) {
  handleError((path = getPathFromURL(path)));
  nullCheck(path);

  if (mode === undefined)
    mode = fs.F_OK;
  else
    mode = mode | 0;

  //binding.access(pathModule._makeLong(path), mode);
  throw new Error('fs.accessSync is not implemented')
};

/**
 * Check `path` exists (can be file, folder or symlync)
 * @param path
 * @return {Boolean}
 */
fs.existsSync = function (path){
  try {
    handleError((path = getPathFromURL(path)));
    nullCheck(path);
    return !!fileStat(pathModule._makeLong(path));
  } catch (e) {
    return false;
  }
};

fs.readFile = function (path, options, callback_){
  var stat = fileStat(path);
  var callback = maybeCallback(arguments[arguments.length - 1]);
  options = getOptions(options, { flag: 'r' });
  if (!stat) {
    callback(new Error('no such file or directory, open \'' + path + '\''));
  } else {
    callback(null, readFileSync(path, options))
  }
};

function tryStatSync(fd, isUserFd) {
  var threw = true;
  var result;
  try {
    result = fileStat(fd);
    threw = false;
  } finally {
    if (threw && !isUserFd) fs.closeSync(fd);
  }
  return result;
}

function tryCreateBuffer(size, fd, isUserFd) {
  var threw = true;
  var buffer;
  try {
    buffer = Buffer.allocUnsafe(size);
    threw = false;
  } finally {
    if (threw && !isUserFd) fs.closeSync(fd);
  }
  return buffer;
}

function tryReadSync(fd, isUserFd, buffer, pos, len) {
  var threw = true;
  var bytesRead;
  try {
    bytesRead = fs.readSync(fd, buffer, pos, len);
    threw = false;
  } finally {
    if (threw && !isUserFd) fs.closeSync(fd);
  }
  return bytesRead;
}

/**
 * Reads the entire contents of a file. If options.encoding == 'bin', then the ArrayBuffer is returned.
 * If no options is specified at all - result is String as in {@link fs.loadFile}
 * @param {String} path  Absolute path to file
 * @param {Object} [options]
 * @param {String|Null} [options.encoding] Default to null. Possible values: 'bin'|'ascii'|'utf-8'
 * @returns {String|ArrayBuffer}
 */
fs.readFileSync = function(path, options) {
  options = getOptions(options, { flag: 'r' });
  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, options.flag || 'r', 0o666);

  let statValues = tryStatSync(fd, isUserFd);
  var size;
  if ((statValues.mode & S_IFMT) === S_IFREG)
    size = statValues.size;
  else
    size = 0;
  var pos = 0;
  var buffer; // single buffer with file data
  var buffers; // list for when size is unknown

  if (size === 0) {
    buffers = [];
  } else {
    buffer = tryCreateBuffer(size, fd, isUserFd);
  }

  var bytesRead;

  if (size !== 0) {
    do {
      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);
      pos += bytesRead;
    } while (bytesRead !== 0 && pos < size);
  } else {
    do {
      // the kernel lies about many files.
      // Go ahead and try to read some bytes.
      buffer = Buffer.allocUnsafe(8192);
      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);
      if (bytesRead !== 0) {
        buffers.push(buffer.slice(0, bytesRead));
      }
      pos += bytesRead;
    } while (bytesRead !== 0);
  }

  if (!isUserFd)
    fs.closeSync(fd);

  if (size === 0) {
    // data was collected into the buffers list.
    buffer = Buffer.concat(buffers, pos);
  } else if (pos < size) {
    buffer = buffer.slice(0, pos);
  }

  if (options.encoding && options.encoding !== 'bin')
    buffer = buffer.toString(options.encoding);
  return buffer;
};

/** Read file names from directory (include folder names).
 * Return array of file names. In case directory not exists - throw error
 * @param {String} path
 * @return {Array.<String>}
 */
fs.readdirSync = function (path) {
    var res = readDir(path, true);
    if (res == null) {
        throw new Error('can not read dir ' + path);
    } else {
        return res;
    }
};

fs.readdir = makeOneArgFuncAsync(fs.readdirSync);

/**
 * Get file statistics. Will throw in case file or folder does not exists.
 * @param path
 * @returns {Boolean|{atime: Date, mtime: Date, ctime: Date, size: number, _fileName: string, isDirectory: function}}
 */
fs.statSync = function (path) {
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
    var oStat;

    oStat = fileStat(path);
    if (oStat === null) throw new Error('ENOENT: no such file or directory, stat ' + fileName)
    oStat._fileName = path;
    oStat.isDirectory = function(){
      return fs.isDir(this._fileName);
    };
	  oStat.isFile = function(){
      return !fs.isDir(this._fileName);
    };
    oStat.isSymbolicLink = function(){
        return false; //TODO - implement
    };
    return oStat;
};

fs.lstatSync = fs.statSync;

fs.stat = function (fileName, callback_) {
   var _stat
   var callback = maybeCallback(arguments[arguments.length - 1]);
   try {
     _stat = statSync(fileName);
     callback(null, _stat);
   } catch (e) {
     callback(e);
   }
};

//todo - lstat is a followSymLync version of stat
fs.lstat = fs.stat;

/**
 * Write to file
 * Actually implements {@link UBWriter#write}
 * @param {String} path  Full absolute file path
 * @param {ArrayBuffer|Object|String} data Data to write. If Object - it stringify before write
 * @param {Object} [options]
 * @param {String} [options.encoding] Encode data to `encoding` before write. Default to `utf-8` in case data is String or `bin` in case data is ArrayBuffer.
 *                              One of "utf-8"|"ucs2"|"bin"|"base64".
 */
fs.writeFileSync = function(path, data, options) {
  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });
  const flag = options.flag || 'w';

  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);

  if (!isUint8Array(data)) {
    if (typeof data !== 'string') {
      try {
        writeFile(fd, data); // ub compatibility workaround
      } finally {
        if (!isUserFd) fs.closeSync(fd);
      }
      return
    }
    data = Buffer.from('' + data, options.encoding || 'utf8');
  }
  var offset = 0;
  var length = data.length;
  var position = /a/.test(flag) ? null : 0;
  try {
    while (length > 0) {
      var written = fs.writeSync(fd, data, offset, length, position);
      offset += written;
      length -= written;
      if (position !== null) {
        position += written;
      }
    }
  } finally {
    if (!isUserFd) fs.closeSync(fd);
  }
};

/**
 * Append data to a file, creating the file if it not yet exists
 * Actually implement {UBWriter#write}
 * @param {String} path  Full absolute file path
 * @param {ArrayBuffer|Object|String} data Data to write. `Object` are stringified before write
 * @param {Object} [options]
 * @param {String} [options.encoding] Encode data to `encoding` before write.
 *  Default to `utf-8` in case data is String or `bin` in case data is ArrayBuffer.
 *  Possible values: "utf-8"|"ucs2"|"bin"|"base64".
 */
fs.appendFileSync = function(path, data, options) {
  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });

  // Don't make changes directly on options object
  options = copyObject(options);

  // force append behavior when using a supplied file descriptor
  if (!options.flag || isFd(path))
    options.flag = 'a';

  fs.writeFileSync(path, data, options);
};

/**
 * Delete file.
 */
fs.unlinkSync = function (path) {
    try{
        return deleteFile(path)
    }catch(e){
        return false;
    }
};

fs.unlink = makeOneArgFuncAsync(fs.unlinkSync);

/**
 * Delete non-empty directory. See {@link removeDir} for details
 * @param {String} path path to remove
 */
fs.rmdirSync = function (path) {
    return removeDir(path);
};

/**
 * Move (rename) file.
 * @param {String} oldPath
 * @param {String} newPath
 */
fs.renameSync = function (oldPath, newPath) {
  nullCheck(oldPath);
  nullCheck(newPath);
  return rename(pathModule._makeLong(oldPath),
    pathModule._makeLong(newPath));
};

/**
 * Fake class for nodeJS compatibility
 */
fs.ReadStream = ReadStream;
function ReadStream(){}

fs.closeSync = function(fd) {
  return closeFile(fd);
};

function modeNum(m, def) {
  if (typeof m === 'number')
    return m;
  if (typeof m === 'string')
    return parseInt(m, 8);
  if (def)
    return modeNum(def);
  return undefined;
}

fs.openSync = function(path, flags, mode) {
  mode = modeNum(mode, 0o666);
  handleError((path = getPathFromURL(path)));
  nullCheck(path);
  return openFile(pathModule._makeLong(path), stringToFlags(flags), mode);
};

fs.readSync = function(fd, buffer, offset, length, position) {
  if (length === 0) {
    return 0;
  }

  return readFile(fd, buffer, offset, length, position);
};

fs.writeSync = function(fd, buffer, offset, length, position) {
  if (isUint8Array(buffer)) {
    if (position === undefined)
      position = null;
    if (typeof offset !== 'number')
      offset = 0;
    if (typeof length !== 'number')
      length = buffer.length - offset;
    return writeFileBuffer(fd, buffer, offset, length/*, position*/);
  }
  if (typeof buffer !== 'string')
    buffer += '';
  if (offset === undefined)
    offset = null;
  return writeFileString(fd, buffer, offset, length, position);
};

//noinspection JSUnusedLocalSymbols
/**
 * Create all missing folders in the given path. Only absolute path supported. Throw error in case of fail
 * @param {String} path path for creation.
 * @param {Number} [mode] Ignored under Windows
 */
fs.mkdirSync = function (path, mode) {
    if (!forceDirectories(path)){
        throw new Error('can\'t create directory ' + path);
    }
};

const emptyObj = Object.create(null);
/**
 * Synchronous realpath(3). Returns the resolved path (resolve symlinks, junctions on Windows, /../)
 */
fs.realpathSync = function realpathSync(p, options) {
  if (!options)
    options = emptyObj;
  else
    options = getOptions(options, emptyObj);
  if (typeof p !== 'string') {
    handleError((p = getPathFromURL(p)));
    if (typeof p !== 'string')
      p += '';
  }
  nullCheck(p);
  p = pathModule.resolve(p);

  const cache = options[internalFS.realpathCacheKey];
  const maybeCachedResult = cache && cache.get(p);
  if (maybeCachedResult) {
    return maybeCachedResult;
  }
  let res = realpath(p);
  if (cache) cache.set(p, res);
  return res;
};
